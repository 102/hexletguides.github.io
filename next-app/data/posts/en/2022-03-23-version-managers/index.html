<h2 id="system-installation">System installation</h2>

<p>To run code in any language, you need to install its interpreter (or compiler). Different operating systems do it differently: some of them use package managers, for example, <em>apt</em> or <em>yum</em>, and some download the installer directly from the repository. Some languages come preinstalled with an operating system, for example, Python. In particular, Python plays a key role in the Linux OS and its distributions.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Ubuntu</span>
<span class="nb">sudo </span>apt <span class="nb">install </span>nodejs <span class="c"># installs most recent version</span>
</code></pre></div></div>
<p>The standard installation method works well only at the very beginning during the initial setup. Then, over time, different problems begin to surfase. For example, at some point, a new version of the language comes out but the project you are working on requires the latest version. Usually, it takes some time before the language becomes available for installation through package managers. And in this case, you either have to wait, which isn’t always convenient, or look for another installation method. The last one often becomes a challenge and takes a lot of time, with hours of googling and installing additional libraries. All this eventually clogs the system and sometimes breaks it.</p>

<p>Another serious problem arises when developer requires different versions of the same language for different programs. It happens surprisingly often since there are plenty of options in development: various company projects, pet-projects, open source.</p>

<p><em>It’s important thing to mention, that all of this doesn’t concern those, who have completely thrown themselves into Docker and Docker Compose. However, even in this case, languages are required to work with open source.</em></p>

<h2 id="version-managers">Version managers</h2>

<p>To solve these problems, the developers came up with version managers. A version manager is a special program designed to handle language versions. With its help it became possible to install the required versions and switch between them. Unlike the package managers that come with operating systems, version managers always allow to install the latest versions of languages as soon as they come out (including installing alpha and beta versions).</p>

<p>For example, you can use <a href="https://github.com/nvm-sh/nvm">NVM</a> (Node Version Manager) for Node.js:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Install NVM</span>
curl <span class="nt">-o-</span> https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
<span class="c"># Installation does not mean activation. After installation, the version that was before installation will remain active</span>
nvm <span class="nb">install </span>node <span class="c"># Install the latest available version of the node</span>
nvm <span class="nb">install </span>6.14.4 <span class="c"># or 10.10.0, 8.9.1, and so on.</span>
nvm ls-remote <span class="c"># list of available versions</span>
nvm use node <span class="c"># Activate the last installed version of the node</span>
nvm use node 17 <span class="c"># Activate the required version</span>
</code></pre></div></div>
<p>To simplify the work, version managers usually enable users to create a special file within the project that captures the required version of the language. In some cases, version managers track this file and switch versions automatically.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">echo</span> <span class="s2">"17"</span> <span class="o">&gt;</span> .nvmrc
<span class="c"># This command spotted .nvmrc file and used the version specified there</span>
<span class="nv">$ </span>nvm use
Found <span class="s1">'/path/to/project/.nvmrc'</span> with version &lt;17&gt;
Now using node v17
</code></pre></div></div>
<p>In today’s world its hard to imagine a language without version manager. Moreover, some of the widely used languages, such as Ruby, have many competitive version managers:</p>
<ul>
  <li>go: gvm, g</li>
  <li>java: jabba</li>
  <li>ruby: rbenv, rvm, chruby</li>
  <li>php: phpenv, phpbrew</li>
  <li>python: pyenv</li>
</ul>

<p>Version managers also solve a few more important tasks. Customarily, when a programmer interacts with a language installed directly, he has to use <em>sudo</em> when installing global packages. The fact is that the standard language installation scheme is intended for all users at once. Hence, all the necessary files, including global packages, get into shared directories that require administrative rights. From the security perspective, this is a vulnerability that developers of open source libraries can exploit (and sometimes they do). Version managers install everything in the current user’s home directory, where he already has full rights. On the one hand, it allows not to run package installation as an administrator, and on the other hand, the system isn’t clogged. Version manager makes it painless to remove a language and all its packages. All you have to do is delete the directory (although it’s better to do this using the version manager tools).</p>

<h2 id="universal-version-manager">Universal version manager</h2>

<p>While solving some problems, version managers also cause a few others. Firstly, there are too many of them, so their popularity constantly changes. Secondly, the process of installing the version manager can be more complicated than installing the language. The problem is that they need to be universal and work everywhere, which is extremely problematic, considering the diversity of modern ecosystems. It’s enough to look at the size of the NVM documentation to assess the scale of the disaster. Thirdly, all these managers work differently and have different commands. It complicates the process of switching between them while working with various languages.</p>

<p>All this led to the next logical step. Eventually, a universal manager <a href="https://asdf-vm.com/">asdf</a> appeared on the scene, and, thanks to plugins, is now able to work with any language. A shortlist of its advantages:</p>

<ul>
  <li>A single command line utility to work with all languages</li>
  <li>A single interface for all languages</li>
  <li>Automatic switching between languages within each project</li>
  <li>A simple plugin system that allows to add any language</li>
</ul>

<p>Now <em>asdf</em> has become quite popular and is gradually replacing every other version managers (technically, language-specific managers are more often used there). It has a bit more complex command system due to the need to support many languages, but otherwise it significantly simplifies the whole process.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># asdf has excellent documentation, which clearly shows how to install it,</span>
<span class="c"># and what dependencies can be required in different systems</span>
<span class="c"># Installing</span>
git clone https://github.com/asdf-vm/asdf.git ~/.asdf <span class="nt">--branch</span> v0.9
<span class="c"># Restart the terminal after that</span>
<span class="nb">echo</span> <span class="s1">'. $HOME/.asdf/asdf.sh'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
<span class="c"># To work with a particular language, it's necessary to install the respective plugin</span>
<span class="c"># The list of available plugins is on the project website</span>
asdf plugin add nodejs
<span class="c"># Language installing</span>
<span class="c"># Instead of nodejs, you need to substitute the name of the plugin you are working with</span>
asdf <span class="nb">install </span>nodejs latest <span class="c"># latest means the latest version of the required language</span>
<span class="c"># Installing the required version</span>
asdf <span class="nb">install </span>nodejs latest
<span class="c"># Installing the required language version by default</span>
asdf global nodejs latest
<span class="c"># Shows current language versions installed through asdf</span>
asdf current
elixir         1.10.1-otp-22 <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
erlang         22.2.7   <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
nodejs         17.0.0   <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
php            7.4.5    <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
python         3.8.2 2.7.16 <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
ruby           2.7.0    <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
yarn           1.22.4   <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
</code></pre></div></div>
<h2 id="conclusion">Conclusion</h2>

<p>Working with different versions of the language is a challenge, which is made easy due to version managers and Docker (for advanced users). Among all managers, <em>asdf</em> stands out and at the same time becomes a universal tool for managing any language and even regular programs.</p>
