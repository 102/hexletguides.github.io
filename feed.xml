<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru_RU"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://guides.hexlet.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://guides.hexlet.io/" rel="alternate" type="text/html" hreflang="ru_RU" /><updated>2021-06-18T13:22:31+00:00</updated><id>https://guides.hexlet.io/feed.xml</id><title type="html">Hexlet Guides</title><subtitle>Полезные статьи и гайды для разработчиков
</subtitle><author><name>Kirill Mokevnin</name></author><entry><title type="html">Что такое деплой?</title><link href="https://guides.hexlet.io/deploy/" rel="alternate" type="text/html" title="Что такое деплой?" /><published>2021-06-11T00:00:00+00:00</published><updated>2021-06-11T00:00:00+00:00</updated><id>https://guides.hexlet.io/deploy</id><content type="html" xml:base="https://guides.hexlet.io/deploy/">&lt;p&gt;Деплой – процесс “разворачивания” веб-сервиса, например, сайта, в рабочем окружении. Рабочее окружение – место где сайт запускается и доступен для запросов. Это может быть как готовый хостинг, так и своя собственная серверная инфраструктура.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Деплоятся не только веб-сервисы, но любые сервисы доступные по сети, даже если эта сеть внутренняя и не доступна для запросов через интернет.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Для понимания деплоя, необходимо разобраться с жизненным циклом кода. Код приложения разрабатывается на рабочей машине разработчика, а запускается в другом месте, называемом продакшеном. Продакшен это среда запуска (иногда говорят боевая среда). Она может состоять из одного сервера, в случае простого приложения, а может состоять из тысяч и десятков тысяч в случае, по настоящему, сложных приложений.&lt;/p&gt;

&lt;p&gt;Как это происходит. Разработчики добавляют код в репозиторий, затем, в какой-то момент решают, что пора доставить его до продакшена. Это может происходить как по регулярному расписанию, например раз в две недели, так и просто по необходимости, вплоть до выкатки после каждого изменения. Во многом количество деплоев зависит от уровня его автоматизации, того, насколько процесс легкий в проведении и отката в случае проблем. На Хекслете деплои выполняются практически после каждого изменения, около 3 деплоев в день.&lt;/p&gt;

&lt;div class=&quot;fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner&quot;&gt;
    &lt;a href=&quot;https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;Интенсив: Девопс для программистов. Вся база за 3 месяца
&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Каждый раз когда разработчики решили что все, пора, они создают релиз. Под релизом, обычно, понимают тег в git, который фиксирует то, что уйдет в деплой. То есть изменения добавленные в мастер после создания тега не повлияют на сам тег, а значит мы точно уверены в том, что деплоим.&lt;/p&gt;

&lt;!-- image --&gt;

&lt;p&gt;Для статических сайтов или отдельного фронтенда (только html, css и статические файлы) деплой сводится к обновлению кода на сервере. В ситуации деплоя бекенда, как минимум, подключается база данных. В общем случае деплой может быть сложной процедурой, занимающей приличное время. В распределенных системах, состоящих из множества независимых веб-сервисов вообще не бывает общего деплоя, каждая часть приложения деплоится (выкатывается) независимо.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Стоит сказать что PaaS платформы, такие как Heroku, берут деплой полностью на себя. Там достаточно выполнить коммит и дальше все произойдет само. Цена за это – стоимость самой платформы&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;шаги-деплоя&quot;&gt;Шаги деплоя&lt;/h2&gt;

&lt;h3 id=&quot;доставка-кода-на-сервер&quot;&gt;Доставка кода на сервер&lt;/h3&gt;

&lt;p&gt;В зависимости от способа упаковки кода возможны разные варианты доставки. Иногда код просто копируют на сервер как набор файлов, но такое встречается редко, чаще он обновляется через git. Раньше был популярен способ деплоя через стандартные пакетные менеджеры Linux дистрибутивов. Сейчас он тоже встречается и для определенных ситуаций подходит лучше всего.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Git: &lt;em&gt;git checkout tag-name&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Docker: &lt;em&gt;docker pull image-name:tag-name&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Apt (Пакет): &lt;em&gt;apt-install application-package-name&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;обновление-базы-данных&quot;&gt;Обновление базы данных&lt;/h3&gt;

&lt;p&gt;Новая версия приложения может и, как правило, требует изменений в базе данных. Для этого во время (или до) деплоя запускают миграции, специальные скрипты, содержащие правила обновления базы данных. Например sql скрипты:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;car&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;license_plate&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;owner&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driver_license_id&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;запуск-и-остановка&quot;&gt;Запуск и остановка&lt;/h3&gt;

&lt;p&gt;Где-то в этом процессе происходит остановка старой версии и запуск новой. Если сначала остановить старую версию, а потом выполнить миграции и запустить новую, то мы получим простой (downtime) в работе сервиса. Так действительно работают многие, но это может быть болезненно для бизнеса и частых деплоев. Поэтому самые продвинутые проекты не останавливаются во время деплоя. О том как это делать ниже.&lt;/p&gt;

&lt;h2 id=&quot;автоматизация&quot;&gt;Автоматизация&lt;/h2&gt;

&lt;p&gt;Деплой нужно максимально автоматизировать, от этого зависит Time To Market, ключевая характеристика бизнес-ориентированных приложений. Чем быстрее и чаще мы доставляем изменения пользователю, тем лучше. Быстрее проверяем гипотезы, быстрее вносим исправления, быстрее оправдываем деньги вложенные в разработку. Без автоматизации разработчики боятся выполнять деплой, он становится обузой, что приводит к снижению числа деплоев и регулярному стрессу для всей команды, с засиживанием на работе до позднего вечера.&lt;/p&gt;

&lt;p&gt;Основных способа автоматизации три:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;С помощью утилит, созданных для конкретных языков. Например в Ruby это Capistrano, одна из первых и наиболее известных утилит подобного рода, ставшая популярной далеко за пределами Ruby. Основная проблема с такими инструментами – сильная завязка на язык&lt;/li&gt;
  &lt;li&gt;С помощью Ansible, в который уже &lt;a href=&quot;https://docs.ansible.com/ansible/latest/collections/community/general/deploy_helper_module.html&quot;&gt;встроен модуль для деплоя&lt;/a&gt;. Идеально подходит для большинства ситуаций деплоя на управляемые сервера&lt;/li&gt;
  &lt;li&gt;Системы оркестрации типа Kubernetes. Если они используются, то без автоматического деплоя никак&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Но даже если автоматизация выполнена, все равно остается задача “запустить деплой”. Запуск тоже автоматизируется. Существует целый подход, который называется &lt;a href=&quot;https://ru.wikipedia.org/wiki/Непрерывная_доставка&quot;&gt;Непрерывная доставка&lt;/a&gt;(continuous delivery). Его сложно внедрить и он не везде подходит, но если получилось, то про деплой забывают. Он выполняется полностью сам без участия людей. Главное, в таком варианте, хороший мониторинг и система оповещения (алертинг) для реакции на ошибки.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# https://docs.ansible.com/ansible/latest/collections/community/general/deploy_helper_module.html#examples&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Initialize the deploy root and gather facts&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;community.general.deploy_helper&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/path/to/root&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Clone the project to the new release folder&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;ansible.builtin.git&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;repo&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ansible.builtin.git://foosball.example.org/path/to/repo.git&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1.1.1&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Add an unfinished file, to allow cleanup on successful finalize&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;ansible.builtin.file&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;/&apos;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;touch&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;zero-downtime-deployment&quot;&gt;Zero Downtime Deployment&lt;/h2&gt;

&lt;p&gt;Если не предпринимать специальных шагов, то каждый деплой будет приводить к остановке (возможно частичной) сервиса. В это время пользователи либо увидят ошибку, либо сообщение о происходящем обновлении. Но такого не происходит на большинстве крупных сервисов в интернете. Почему? Из-за реализации подхода “деплой без даунтайма” (downtime – простои в работе сервиса).&lt;/p&gt;

&lt;p&gt;Zero Downtime Deployment выглядит так, как будто сервис никогда не останавливается, но при этом обновляется. Достигается это за счет одновременного запуска старой версии и новой кода. То есть когда деплоится приложение, то сначала поднимается новая версия рядом со старой и только когда автоматика убеждается, что новая версия запустилась и работает, происходит остановка старой версии. Для выполнения этой процедуры понадобится следующее:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Инфраструктура. Нужен балансировщик, который может, переключать трафик (входящие соединения от браузеров или других систем) между старой и новой версией кода. И желательно иметь как минимум два сервера, хотя это и не обязательно&lt;/li&gt;
  &lt;li&gt;Деплой. Процесс деплоя без простоя значительно сложнее чем с остановкой. Проще всего такой деплой делается на системах оркестрации, например, Kubernetes&lt;/li&gt;
  &lt;li&gt;Культура кода. Обеспечить безостановочную работу невозможно без определенной культуры написания кода. Чтобы старая и новая версия могли работать одновременно, нужно следить за всеми интерфейсами. Важно соблюдение обратной совместимости (работа с api, базой, очередьми и, в целом, любыми хранилищами)&lt;/li&gt;
  &lt;li&gt;База данных. Она должна быть обратна совместима между старой и новой версией. Все миграции только вперед (их нельзя откатывать!) и только на добавление. Нельзя удалять и обновлять (переименовывать, менять тип) колонки и таблицы&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;extensions/v1beta1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;tomcat-deployment-${TARGET_ROLE}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;tomcat&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;role&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;${TARGET_ROLE}&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;tomcat-container&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;tomcat:${TOMCAT_VERSION}&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8080&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;readinessProbe&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;httpGet&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8080&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;дополнительная-литература&quot;&gt;Дополнительная литература&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://bronevichok.ru/posts/engineering-at-booking.com.html&quot;&gt;Инжиниринг в Booking&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://habr.com/ru/company/flant/blog/471620/&quot;&gt;Стратегии деплоя&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=WPCz_U7D8PI&quot;&gt;Stateless vs Statefull&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ansistrano/deploy&quot;&gt;Ansistrano (Ansible + Capistrano)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ru.hexlet.io/blog/posts/environment&quot;&gt;Среды разработки&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Деплой – процесс “разворачивания” веб-сервиса, например, сайта, в рабочем окружении. Рабочее окружение – место где сайт запускается и доступен для запросов. Это может быть как готовый хостинг, так и своя собственная серверная инфраструктура.</summary></entry><entry><title type="html">Полезные треды в твиттере</title><link href="https://guides.hexlet.io/usefull-twitter-threads/" rel="alternate" type="text/html" title="Полезные треды в твиттере" /><published>2021-06-10T00:00:00+00:00</published><updated>2021-06-10T00:00:00+00:00</updated><id>https://guides.hexlet.io/usefull-twitter-threads</id><content type="html" xml:base="https://guides.hexlet.io/usefull-twitter-threads/">&lt;h2 id=&quot;про-tdd&quot;&gt;Про TDD&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Про TDD. Я часто пишу тесты до кода, но при этом не работаю по TDD. Почему? Небольшой тред&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;https://twitter.com/mokevnin/status/1353796108594671617&lt;/p&gt;

&lt;h2 id=&quot;мифы-вокруг-ооп&quot;&gt;Мифы вокруг ООП&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Метатред по серии “Мифы В ООП”, в которой я постарался раскрыть тему со всех сторон, от разных людей/языков/эпох. Виды ооп, полиморфизм, паттерны и многое другое. #oopmyths&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;https://twitter.com/mokevnin/status/1376234798465871874&lt;/p&gt;

&lt;h2 id=&quot;автоматное-программирование&quot;&gt;Автоматное программирование&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Метатред по серии “Автоматное программирование”. Рассказываю тут про флаговое программирование, явно выделенное состояние, автоматы на бекенде, автоматы на фронтенде и кидаюсь кучей полезнях #FSM&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;https://twitter.com/mokevnin/status/1392160550113660935&lt;/p&gt;

&lt;h2 id=&quot;о-функциях&quot;&gt;О Функциях&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Поехали! Обычно, от функций ожидают сокращения дублирования кода. Да, функции устраняют дублирование, но лишь в дополнение к тому, зачем они нужны. Настоящий смысл функции – повышение уровня абстракции. Звучит немного абстрактно, поэтому раскроем подробнее =&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;https://twitter.com/mokevnin/status/1396824737540722688&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Про TDD</summary></entry><entry><title type="html">Что такое “управление конфигурацией”?</title><link href="https://guides.hexlet.io/configuration-management/" rel="alternate" type="text/html" title="Что такое “управление конфигурацией”?" /><published>2021-06-04T00:00:00+00:00</published><updated>2021-06-04T00:00:00+00:00</updated><id>https://guides.hexlet.io/configuration-management</id><content type="html" xml:base="https://guides.hexlet.io/configuration-management/">&lt;p&gt;Сайты это не только код, но и инфраструктура для их запуска. В первую очередь, в нее входят сервера, на которых крутится код, база данных и различные вспомогательные системы. Иногда все это помещается на один сервер, в более сложных ситуациях количество серверов измеряется тысячами, а для обслуживания таких систем привлекаются целые команды инженеров (разного рода администраторов). Независимо от размера сайта, проблемы обслуживания инфраструктуры у всех очень похожие. Поговорим об одной конкретной – настройке сервера.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Существуют подходы, которые позволяют избежать прямого взаимодействия с инфраструктурой. В рамках статьи они не рассматриваются, но знать про них полезно. К ним относятся: классические хостинги с предустановленным софтом, serverless, хостинги статических сайтов, PaaS решения и kubernetes (и его аналоги)&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner&quot;&gt;
    &lt;a href=&quot;https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;Интенсив: Девопс для программистов. Вся база за 3 месяца
&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;В подавляющем большинстве случаев, сервера арендуются у хостинговых компаний, таких как &lt;a href=&quot;https://m.do.co/c/e702f9a99145&quot;&gt;DigitalOcean&lt;/a&gt; или AWS. Делается это за 5 минут нажатием буквально нескольких кнопок. Нас попросят выбрать характеристики сервера, операционную систему и датацентр, в котором он будет развернут. В результате, мы получаем машину (виртуальную), с предустановленной операционной системой и ip-адресом для входа по ssh.&lt;/p&gt;

&lt;!-- image: DO --&gt;

&lt;p&gt;Новая машина содержит только основную операционную систему с небольшим набором предустановленных программ. Перед тем как запустить на ней какой-то сервис, например, обычный сайт, понадобится установить дополнительные пакеты. Набор пакетов зависит от стека технологий, на котором он написан. Если сайт “завернут” в Docker, то настройка значительно упрощается и сводится к установке самого Docker. В остальных случаях придется потратить какое-то время на донастройку и конфигурирование. Помимо пакетов, часто требуется настраивать саму систему, менять конфигурационные файлы, права на файлы и директории, создавать пользователей и так далее:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Как это могло бы быть&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Сервер на Ubuntu&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Заходим на удаленную машину&lt;/span&gt;
ssh root@ipaddress

&lt;span class=&quot;c&quot;&gt;# Создание пользователя для деплоя&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Где-то здесь копируются ssh ключи&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;adduser deploy

&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;curl
&lt;span class=&quot;c&quot;&gt;# установка Node.js&lt;/span&gt;
curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://deb.nodesource.com/setup_16.x | &lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-E&lt;/span&gt; bash -
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;nodejs
&lt;span class=&quot;c&quot;&gt;# установка и настройка Nginx&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;nginx
vim /etc/nginx/default.conf

&lt;span class=&quot;c&quot;&gt;# Формирование структуры директорий для сервиса&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /opt/hexlet/versions/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Процесс первоначальной настройки занимает часы и даже дни. Постоянно придется что-то подкручивать, донастраивать и устанавливать. Цикл повториться снова, когда понадобится перейти на новые версии пакетов. Снова придется заходить на сервер, вспоминать что и где настраивалось и как мягко обновиться ничего не сломав. В чем проблема ручной настройки?&lt;/p&gt;

&lt;p&gt;Сервера могут умирать и делать это внезапно. Сколько времени уйдет на “раскатку” нового сервера? Практически столько же времени, сколько было потрачено первый раз. Порядок действий и нужные настройки просто никто не вспомнит даже через неделю после настройки, что уже говорить если прошли месяцы. Более того, вдруг тот кто изначально это делал уже не работает в компании или находится в отпуске. Что тогда? Придется долго извиняться перед пользователями за длительный простой и хорошо если бизнес от этого пострадает не сильно.&lt;/p&gt;

&lt;p&gt;Переустановка сервера не обязательно связана с какими-то форс-мажорными обстоятельствами. В компаниях с хорошей инженерной культурой, сервера меняются на регулярной основе. Как минимум это важно для безопасности. Операционные системы содержат уязвимости, которые закрываются новыми пакетами или версиями. Следить за этим довольно сложно, поэтому проще регулярно освежать инфраструктуру. С другой стороны, обновление сервера может легко сломать рабочее приложение и вызвать простой в работе. Единственный способ гарантировать беспрерывную работу во время обновления – поднимать рядом еще один сервер и настраивать его. Затем сервис просто выкатывается на новый сервер, а старый выключается.&lt;/p&gt;

&lt;h2 id=&quot;автоматизация&quot;&gt;Автоматизация&lt;/h2&gt;

&lt;p&gt;Хорошо бы было автоматизировать настройку сервера. Для этого существует несколько подходов, которые мы рассмотрим ниже.&lt;/p&gt;

&lt;h3 id=&quot;bash-скрипты&quot;&gt;Bash-скрипты&lt;/h3&gt;

&lt;p&gt;В простейшем случае для этого достаточно обычного Bash-скрипта, в который последовательно добавляются команды, которые ранее мы запускали руками. Затем все сводится к копированию скрипта на сервер и запуску:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Копирование на сервер с помощью scp&lt;/span&gt;
scp mybashscript.sh root@ipaddress:~/

&lt;span class=&quot;c&quot;&gt;# Заходим на сервер и запускаем скрипт&lt;/span&gt;
ssh root@ipaddress
sh ~/mybashscript.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если перенести команды в bash-скрипт “как есть”, без модификации, то, скорее всего, нам придется постоянно следить за выводом и не забывать подтверждать установку пакетов, так как это поведение по умолчанию:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;➜  ~ apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;golang
The following additional packages will be installed:
  golang-1.13 golang-1.13-doc golang-1.13-go golang-1.13-race-detector-runtime golang-1.13-src golang-doc golang-go
Need to get 63.5 MB of archives.
After this operation, 329 MB of additional disk space will be used.
Do you want to &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;? &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Y/n] &lt;span class=&quot;c&quot;&gt;# Скрипт останавливается и ждет ответа&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Автоматическое “да” добавляется опцией &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-y&lt;/code&gt;. У других команд свои опции для подавления взаимодействия с пользователем. Придется их все учесть.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; golang
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Другая проблема серьезнее, она связана с понятием “идемпотентность”. Что будет если выполнить команду создания директории два раза?&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; /hexlet
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; /hexlet &lt;span class=&quot;c&quot;&gt;# ?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Команда завершится с ошибкой, она не идемпотентна. То есть последовательные вызовы одной и той же команды приводят к разному результату. Идемпотентность для настройки сервера &lt;a href=&quot;https://ru.hexlet.io/blog/posts/pochemu-vazhna-idempotentnost-i-kak-pisat-idempotentnye-bash-skripty&quot;&gt;очень важна&lt;/a&gt;. Иначе повторный запуск скрипта настройки завершится с ошибкой. А повторные запуски нужны, например в случае отладки самого скрипта, когда мы его только пишем и проверяем как он работает. В случае с командой &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mkdir&lt;/code&gt; идемпотентности добиться легко, достаточно добавить флаг &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-p&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /hexlet
&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; /hexlet &lt;span class=&quot;c&quot;&gt;# ошибки не будет&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Но, к сожалению не все команды поддерживают такую возможность. Для многих ситуаций, идемпотентность нужно обеспечивать самостоятельно, что резко усложнит скрипт. Из простого набора команд он превратиться в реальный код с условными конструкциями. И в какой-то момент разбираться в нем станет крайне сложно. Через это проходили многие, особенно раньше, когда не было альтернативы.&lt;/p&gt;

&lt;p&gt;Но дело не только в идемпотентности. Часть задач, которые легко делались руками, становятся сложными в автоматизации. Представьте, что для изменения конфигурации нужно поправить конкретную строчку внутри файла. Как это легко сделать с помощью bash? Никак, придется либо полностью заменять файл копируя всего содержимое в bash-скрипт (или рядом с ним), либо использовать, что-то вроде sed для точечной замены строки.&lt;/p&gt;

&lt;p&gt;И последнее, но очень важное ограничение. Bash-скрипт нужно доставить на сервер самостоятельно. И если для одного сервера это еще как-то можно автоматизировать, то для нескольких “раскатка” скрипта становится проблемой. Становится важно делать это параллельно иначе настройка растягивается на часы даже в случае полной автоматизации. Добавьте сюда разные сервера со своими скриптами, которые отличаются от других.&lt;/p&gt;

&lt;p&gt;На этом этапе bash-скрипты перестают помогать, нужно придумывать что-то еще. Так стали появляться специализированные инструменты для конфигурирования серверов. Одними из первых были проекты Chef и Puppet. Сейчас же, наибольшую популярность приобрел Ansible, который значительно проще в освоении и использовании.&lt;/p&gt;

&lt;h2 id=&quot;ansible&quot;&gt;Ansible&lt;/h2&gt;

&lt;p&gt;Система управления конфигурацией (серверов), которая решает все проблемы описанные выше и, даже больше, может использоваться не только для настройки, но и для деплоя, то есть установки и запуска сервиса. Для установки Ansible воспользуйтесь одним из &lt;a href=&quot;https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html&quot;&gt;предложенных способов&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;В минимальном виде, Ansible конфигурация выглядит как два файла, один – описание серверов, второй – команды, которые мы хотим выполнить. Ansible сам подключается к удаленным серверам и выполняет необходимые команды. Главное дать доступ к этим серверам, например с помощью ssh-ключей.&lt;/p&gt;

&lt;p&gt;Описание серверов хранится в файле &lt;em&gt;inventory.ini&lt;/em&gt;. Ansible использует его для определения машин, на которые нужно выполнить установку.&lt;/p&gt;

&lt;div class=&quot;language-ini highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;; адрес машины, которую настраиваем
; для простоты говорим Ansible использовать локальный компьютер
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;127.0.0.1&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;ansible_connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;local&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Команды настройки сервера записываются в файлы называемые плейбуками. Плейбуки создаются в формате yaml под любым именем. Например playbook.yaml:&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# hosts – означает группу машин, на которой нужно выполниться&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# all – означает все описанные в inventory.ini&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;hosts&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;all&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# набор команд которые нужно выполнить&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ansible.builtin.file&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# file – управляет файлами и директориями&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/tmp/ansible_was_here&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;touch&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# выполнит команду touch если файла не существует. И – идемпотентность&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Файловая структура может выглядеть так:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;tree &lt;span class=&quot;c&quot;&gt;# вывод содержимого директории&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
├── inventory.ini
└── playbook.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь запускаем:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Запуск Ansible идет на локальной машине!&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Запускать нужно в той же директории, где созданы файлы&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# -i означает inventory.ini&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# https://github.com/hexlet-boilerplates/ansible&lt;/span&gt;
ansible-playbook &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; inventory.ini playbook.yaml

PLAY &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Server Setup] &lt;span class=&quot;k&quot;&gt;***********************************************************************************************************&lt;/span&gt;

TASK &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Gathering Facts] &lt;span class=&quot;k&quot;&gt;********************************************************************************************************&lt;/span&gt;
ok: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;127.0.0.1]

TASK &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file] &lt;span class=&quot;k&quot;&gt;*******************************************************************************************************************&lt;/span&gt;
changed: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;127.0.0.1]

PLAY RECAP &lt;span class=&quot;k&quot;&gt;********************************************************************************************************************&lt;/span&gt;
127.0.0.1                  : &lt;span class=&quot;nv&quot;&gt;ok&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2    &lt;span class=&quot;nv&quot;&gt;changed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1    &lt;span class=&quot;nv&quot;&gt;unreachable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0    &lt;span class=&quot;nv&quot;&gt;failed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0    &lt;span class=&quot;nv&quot;&gt;skipped&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0    &lt;span class=&quot;nv&quot;&gt;rescued&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0    &lt;span class=&quot;nv&quot;&gt;ignored&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вывод говорит о том, что плейбук успешно выполнен. В результате в директории &lt;em&gt;/tmp&lt;/em&gt; окажется файл &lt;em&gt;ansible_was_here&lt;/em&gt;. Повторный запуск плейбука тоже закончится успешно, но из вывода будет видно, что он не сделает никаких изменений, так как Ansijble сам обеспечивает идемпотентность. В данном случае, он проверит наличие файла и пропустит команду если файл существует. Если в &lt;em&gt;inventory.ini&lt;/em&gt; указать несколько ip-адресов, то Ansible выполнит плейбук на каждом из них, причем сделает это параллельно. Единственное о чем нужно не забыть – добавить ssh-ключи на эти машины, иначе Ansible не сможет до них достучаться.&lt;/p&gt;

&lt;div class=&quot;fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner&quot;&gt;
    &lt;a href=&quot;https://ru.hexlet.io/courses/ansible?utm_source=hexlet-guides&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;Курс по Ansible с практикой прямо в браузере&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Что из себя представляет плейбук? Главное внутри него – набор задач (tasks), которые мы хотим выполнить. В отличии от bash-скрипта, задачи это не просто bash-команды. На каждую задачу в Ansible встроен модуль для работы с определенной частью системы. Например внутри Ansible есть модули для работы с git, пакетными менеджерами, файлами и тому подобным. Всего их сотни на все случаи жизни. Именно благодаря готовым интеграциям, Ansible знает как работают те или иные части системы, что позволяет добавить нужные проверки для обеспечения идемпотентности. Пара примеров:&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# Установка postgresql&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Ensure postgresql is at the latest version&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;ansible.builtin.apt&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# модуль apt&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;postgresql&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;latest&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# Запуск postgresql&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Ensure that postgresql is started&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;ansible.builtin.service&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# модуль service&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;postgresql&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;started&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# запускаем если не запущен&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Как видите, Ansible достаточно прост для начала, при этом у него много возможностей, которые можно изучать по мере погружения и усложнения инфраструктуры.&lt;/p&gt;

&lt;h2 id=&quot;итого&quot;&gt;Итого&lt;/h2&gt;

&lt;p&gt;Управление конфигурацией, в современном мире, выполняется с помощью специализированных программ, которые умеют подключаться к удаленным серверам, параллельно настраивать их обеспечивая идемпотентность операций. При таком подходе важно перестать настраивать сервера напрямую. Любые изменения теперь должны делаться через инструмент автоматизации, иначе все вернется к изначальным проблемам. Управление конфигурацией через код повышает взаимозаменяемость людей, позволяет легко отслеживать изменения просто просматривая историю git, подключать других членов команды к управлению инфраструктурой.&lt;/p&gt;

&lt;h2 id=&quot;дополнительные-ссылки&quot;&gt;Дополнительные ссылки&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;https://github.com/hexlet-boilerplates/ansible&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Сайты это не только код, но и инфраструктура для их запуска. В первую очередь, в нее входят сервера, на которых крутится код, база данных и различные вспомогательные системы. Иногда все это помещается на один сервер, в более сложных ситуациях количество серверов измеряется тысячами, а для обслуживания таких систем привлекаются целые команды инженеров (разного рода администраторов). Независимо от размера сайта, проблемы обслуживания инфраструктуры у всех очень похожие. Поговорим об одной конкретной – настройке сервера.</summary></entry><entry><title type="html">Что такое трекинг ошибок?</title><link href="https://guides.hexlet.io/error-tracking/" rel="alternate" type="text/html" title="Что такое трекинг ошибок?" /><published>2021-01-18T00:00:00+00:00</published><updated>2021-01-18T00:00:00+00:00</updated><id>https://guides.hexlet.io/error-tracking</id><content type="html" xml:base="https://guides.hexlet.io/error-tracking/">&lt;p&gt;Программ без ошибок не бывает. Их количество можно уменьшить с помощью системы типов, линтеров, тестов или даже целого отдела тестировщиков, но убрать совсем невозможно. Это реальность с которой мы живем и лучшее, что можно сделать, научиться эти ошибки отслеживать и быстро исправлять.&lt;/p&gt;

&lt;h2 id=&quot;как-не-надо-работать-с-ошибками&quot;&gt;Как не надо работать с ошибками&lt;/h2&gt;

&lt;p&gt;Как, часто, происходит в разработке. Программисты написали какой-то код, выпустили новую версию сайта/приложения и пошли дальше заниматься своими делами. В это время у некоторых пользователей обнаруживаются проблемы: что-то зависает, формы не отправляются, данные отображаются неправильно и так далее. Такое может продолжаться довольно долго, пока кто-то разгневанный не напишет письмо в службу поддержки. Затем по цепочке это долетает до программистов, которые пытаются понять у кого произошла ошибка, где она случилась, и при каких обстоятельствах. Начинаются выяснения всех подробностей с вероятным привлечением клиента, если тот согласится помочь. При таком подходе, большое количество ошибок остается незамеченным очень долго и, самое неприятное, пользователи уходят. Можно ли этого избежать? Оказывается можно.&lt;/p&gt;

&lt;div class=&quot;fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner&quot;&gt;
    &lt;a href=&quot;https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;Интенсив: Девопс для программистов. Вся база за 3 месяца
&lt;/a&gt;
&lt;/div&gt;

&lt;h2 id=&quot;как-надо-работать-с-ошибками&quot;&gt;Как надо работать с ошибками&lt;/h2&gt;

&lt;p&gt;Существует целый класс сервисов называемых Error Trackers. Они в реальном времени собирают информацию о возникающих ошибках и оповещают об этом команду разработки. Эти сервисы работают буквально со всеми существующими платформами начиная от телевизоров, заканчивая мобильными приложениями и сайтами (и фронтенд и бекенд).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/error-tracking/rollbar-dashboard.jpg&quot; alt=&quot;Rollbar Dashboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Выше пример дашборда сервиса &lt;a href=&quot;https://rollbar.io/&quot;&gt;rollbar.io&lt;/a&gt;, который используется для всех проектов Хекслета. На дашборде выводится частота появления критичных ошибок за последние 24 часа по всем проектам. Этот график позволяет быстро оценить места, куда нужно внимательнее смотреть. А ниже вывод ошибок конкретного проекта. Судя по иконкам, большая часть ошибок прямо сейчас приходит из JavaScript.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/error-tracking/rollbar-project.jpg&quot; alt=&quot;Rollbar Project&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Каждый такой сервис сервис предоставляет библиотеки под разные языки и платформы, которые встраиваются в код и вызываются в случае возникновении ошибок. Эти библиотеки отправляют не только саму ошибку, но и информацию об окружении, которая может помочь. В нее могут входить данные о пользователе, о его браузере, о настройках приложения и так далее.&lt;/p&gt;

&lt;p&gt;В идеальном случае такая библиотека сразу &lt;a href=&quot;https://docs.rollbar.com/docs/rails&quot;&gt;интегрирована&lt;/a&gt; в какой-нибудь фреймворк, например Rails. Тогда не придется практически ничего настраивать, достаточно подключить библиотеку как плагин к фреймворку и дальше он начнет собирать ошибки сам, без дополнительного вмешательства. Если такой интеграции нет, то придется написать немного кода для связи своего приложения с библиотекой. Подробнее о том как это сделать, нужно смотреть в документации выбранного вами сервиса. &lt;a href=&quot;https://docs.rollbar.com/docs/react&quot;&gt;Вот&lt;/a&gt; пример интеграции Rollbar в React. После того как все заработает, пойманная ошибка будет выглядеть примерно так:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/error-tracking/rollbar-error.jpg&quot; alt=&quot;Rollbar Error&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Обратите внимание на меню сверху. По названиям вкладок видно сколько полезного извлекается из ошибки.&lt;/p&gt;

&lt;p&gt;Но поймать ошибку это только половина дела. Дальше нужно как-то оповестить команду, причем так, чтобы не завалить всех спамом. Дело в том, что ошибки обычно не происходят один раз. Если ошибка общая и количество пользователей большое, то можно легко поймать одну ошибку тысячи раз в минуту. И если бы на каждое возникновение уходила нотификация (на емейл или в слак), то такой сервис быстро бы отключили от источника питания.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/error-tracking/rollbar-notifications.jpg&quot; alt=&quot;Rollbar Error&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Поэтому подобные трекеры работают хитро. Когда ошибка произошла первый раз, то сервис высылает оповещение чтобы команда разработки могла оперативно среагировать на инцендент. Если ошибка возникает снова, то больше никаких оповещений. По крайней мере не на каждое возникновение. Оповещения например могут уходить на первое, десятое, сотое, тысячное и так далее возникновение. Это первая часть механизма. Дальше, когда выкатывается новая версия приложения, трекеры помечают ошибки как “поправленные”. Это позволяет легко отслеживать ошибки, которые либо забыли поправить, либо поправили неправильно. Поэтому обычно после деплоя начинают сыпаться оповещения) Для работы этого механизма нужно оповещать трекер о деплоях. Подробно об этом &lt;a href=&quot;https://docs.rollbar.com/docs/deploy-tracking&quot;&gt;написано в документации&lt;/a&gt; соответствующего трекера.&lt;/p&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Трекеры ошибок не игрушка, а серьезный инструмент, без которого невозможно представить себе ни один продакшен. В качестве трекера, при этом, может выступать как один из многих сервисов, так и специализированный софт (например &lt;a href=&quot;https://github.com/getsentry/sentry&quot;&gt;Sentry&lt;/a&gt;), установленный к себе на сервера в случае повышенных требований к безопасности.&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Программ без ошибок не бывает. Их количество можно уменьшить с помощью системы типов, линтеров, тестов или даже целого отдела тестировщиков, но убрать совсем невозможно. Это реальность с которой мы живем и лучшее, что можно сделать, научиться эти ошибки отслеживать и быстро исправлять.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/hosting/servers.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/hosting/servers.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое домен и хостинг?</title><link href="https://guides.hexlet.io/hosting/" rel="alternate" type="text/html" title="Что такое домен и хостинг?" /><published>2021-01-18T00:00:00+00:00</published><updated>2021-01-18T00:00:00+00:00</updated><id>https://guides.hexlet.io/hosting</id><content type="html" xml:base="https://guides.hexlet.io/hosting/">&lt;h2 id=&quot;доменное-имя-домен&quot;&gt;Доменное имя (домен)&lt;/h2&gt;

&lt;p&gt;Когда интернет только зарождался, у сайтов не было доменных имён. Для обращения к сайту использовались прямые IP-адреса машин (серверов), например, 10.132.234.4 (вместо понятного hexlet.io). Довольно быстро стало понятно, что это слишком сложно для запоминания. К тому же адреса могли меняться. Нужно было что-то вроде записной книжки для адресов.&lt;/p&gt;

&lt;div class=&quot;fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner&quot;&gt;
    &lt;a href=&quot;https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;Интенсив: Девопс для программистов. Вся база за 3 месяца
&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Первым решением стал специальный файл &lt;em&gt;hosts&lt;/em&gt;, расположенный на каждой машине, с которой происходил доступ к сайтам. Он содержит сопоставление между IP-адресом и именем, удобным для запоминания. Этот файл существует до сих пор и часто используется программистами во время разработки. Формат файла:&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;# Формат файла: &amp;lt;ip-адрес&amp;gt; &amp;lt;имена сайта&amp;gt;
34.117.253.138 hexlet.io
172.10.11.200 facebook.com m.facebook.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Когда происходит запрос по адресу, например, hexlet.io, то сначала проверяется файл &lt;em&gt;hosts&lt;/em&gt;, и если домен найден (как в примере выше), то браузер устанавливает соединение с сервером. В нашем примере он пойдёт по адресу &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;34.117.253.138&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Пример обращения к DNS с помощью утилиты host&lt;/span&gt;
host hexlet.io
hexlet.io has address 34.117.253.138
hexlet.io mail is handled by 10 alt4.aspmx.l.google.com.
hexlet.io mail is handled by 1 aspmx.l.google.com.
hexlet.io mail is handled by 10 alt3.aspmx.l.google.com.
hexlet.io mail is handled by 5 alt1.aspmx.l.google.com.
hexlet.io mail is handled by 5 alt2.aspmx.l.google.com.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Такой подход оказался очень неэффективен. В каждой подсети использовался собственный файл hosts, который рассылался на все компьютеры, входящие в подсеть. Кроме того, если появляется новый сайт, то всех нужно оповестить. Да и самих сайтов становилось слишком много. Для решения этих проблем создали Domain Name System (DNS). Основное предназначение этой системы заключается в сопоставлении имени домена конкретному IP-адресу, на котором находится сайт. Другими словами, любой сервис может обратиться к DNS и спросить «какой IP-адрес у домена hexlet.io?».&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/hosting/dns.png&quot; alt=&quot;Как работает DNS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Важно понимать, что DNS — это именно служба, а не конкретный сервер. Так как весь интернет зависит от стабильности работы этой системы, то в неё входит множество серверов по всему миру. Кроме того, DNS устроена таким образом, что нет центральной организации, управляющей этими серверами. Подробнее о DNS прочитайте в &lt;a href=&quot;https://guides.hexlet.io/dns/&quot;&gt;нашем гайде&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;хостинг&quot;&gt;Хостинг&lt;/h2&gt;

&lt;p&gt;Интернет — это глобальная сеть, объединяющая огромное число устройств. К устройствам относятся далеко не только стационарные компьютеры и ноутбуки, но также и мобильные устройства, камеры, различные электронные и бытовые приборы. Хотя все эти устройства совершенно разные, они без проблем общаются друг с другом с помощью единого языка. Таким языком в мире машин стал стек протоколов &lt;a href=&quot;https://ru.wikipedia.org/wiki/TCP/IP&quot;&gt;TCP/IP&lt;/a&gt;. Не вдаваясь в детали, скажем, что протокол — это правила, по которым происходит общение. При этом природа общающихся устройств не важна.&lt;/p&gt;

&lt;p&gt;Главным элементом в TCP/IP является IP-адрес. В версии IPv4 он выглядит так: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.123.23.1&lt;/code&gt;. Четыре числа, разделённые точкой. У всех устройств, подключенных к сети напрямую, этот адрес уникальный. Фактически, любой запрос в интернете всегда обращается к какому-то IP-адресу, даже если вы этого не видите.&lt;/p&gt;

&lt;p&gt;Среди компьютеров, подключённых к интернету, выделяется класс машин, которые выполняют роль серверов. Эти сервера, как правило, располагаются у хостеров, и именно они обслуживают многочисленные интернет сайты.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/hosting/servers.png&quot; alt=&quot;Серверные стойки&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Хостер — это компания, предоставляющая услугу, называемую хостинг, то есть ресурсы для размещения и обслуживания сайта в интернете. Хостинг бывает очень разным, начиная от уже полностью готовой среды, в которую заливается код сайта, до железных серверов, которыми можно и нужно управлять самостоятельно.&lt;/p&gt;

&lt;p&gt;Работает это обычно так: после регистрации на сайте хостера выбирается тариф, привязывается банковская карточка, и с вас списывается ежемесячная плата за обслуживание и дополнительные услуги. Взамен вы получаете доступ к вашим ресурсам, например, IP-адрес и пару логин/пароль для ssh- или ftp-доступа.&lt;/p&gt;

&lt;p&gt;Однако есть и бесплатные хостинги, требующие только базовых знаний веб-разработки. Чтобы разместить свою страницу в интернете может быть достаточно возможностей бесплатного Github Pages и одной HTML-страницы. Там же можно получить домен третьего уровня или привязать собственный. Подробнее это рассматривается в наших профессиях в уроке &lt;a href=&quot;https://ru.hexlet.io/courses/layout-designer-basics/lessons/publication/theory_unit&quot;&gt;Публикация в интернете&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;виды-хостингов-on-prem-iaas-paas-saas&quot;&gt;Виды хостингов: On-Prem, IaaS, PaaS, SaaS&lt;/h3&gt;

&lt;p&gt;Вы можете использовать старый компьютер, как собственный хостинг, но придётся самостоятельно обеспечивать его постоянную доступность в интернете, защиту от атак и обновление софта. Такое решение будет называться On-Premises. Вместо рукопашки можно воспользоваться решениями “as Service”:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;IaaS — Infrastructure as a Service, инфраструктура как услуга;&lt;/li&gt;
  &lt;li&gt;PaaS — Platform as a Service, платформа как услуга;&lt;/li&gt;
  &lt;li&gt;SaaS — Software as a Service, программное обеспечение как услуга.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Каждый термин означает разный уровень ответственности. В случае с &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt; от вас требуется только написать HTML и загрузить его в сервис, остальное решается через интерфейс (панель управления), а вся “магия” происходит на стороне сервиса. Это решение SaaS.&lt;/p&gt;

&lt;p&gt;Одно из популярных решений PaaS является &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt;, предоставляющая множество удобных бесплатных инструментов. Практический навык работы с Heroku студенты получают при работе над 4-м проектом в наших профессиях.&lt;/p&gt;

&lt;p&gt;А среди популярных решений IaaS — это &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;Amazon Web Services&lt;/a&gt;. Примечательно, что Heroku использует AWS для размещения ваших ресурсов, то есть выступает посредником, упрощая многие процедуры управления серверами.&lt;/p&gt;

&lt;p&gt;Популярна визуализация этих решений на примере приготовления пиццы, где On-Prem требует наличия и ингредиентов, и инструментов, а SaaS представлен пиццерией, куда вы приходите чтобы съесть пиццу:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/hosting/pizza-as-service.png&quot; alt=&quot;Пицца as service&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;заключение&quot;&gt;Заключение&lt;/h2&gt;

&lt;p&gt;Итак, чтобы создать собственный сайт, вам понадобится домен, хостинг и курсы программирования. Выдачей доменов занимаются организации, именуемые регистраторами. На их сайте вы можете подобрать незанятый домен и оплатить его. После этого каждый год необходимо продление, иначе он вновь станет свободным, и его смогут купить другие. Затем, прямо там же у регистратора, вы можете настроить DNS, например, указать адрес вашего хостинга (в реальности все чуть сложнее, сначала надо указать NS-сервера), на котором находится сайт. Спустя примерно сутки ваш сайт начнёт открываться. Такой срок связан с тем, что информация о новой связке домен-адрес должна распространиться по всем DNS серверам по всему миру. Такая же история происходит и при изменении IP-адреса. Процесс может занять до суток.&lt;/p&gt;

&lt;p&gt;Хостинг может быть простым и бесплатным, а может быть платным и требующим специальных знаний и навыков администрирования. Можно начать с размещения на бесплатном хостинге с бесплатным доменом. Но не следует путать регистраторов доменных имён и хостеров. Часто хостеры выступают как посредники и предлагают купить домены через себя, но, в общем случае, регистраторы — это отдельные компании, которые никак не связаны с хостингом.&lt;/p&gt;

&lt;p&gt;А получить все необходимые навыки программирования и работы с веб-приложениями можно с нашими наставниками в одной из профессий: https://ru.hexlet.io/professions&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Доменное имя (домен)</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/hosting/servers.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/hosting/servers.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое логирование?</title><link href="https://guides.hexlet.io/logging/" rel="alternate" type="text/html" title="Что такое логирование?" /><published>2021-01-18T00:00:00+00:00</published><updated>2021-01-18T00:00:00+00:00</updated><id>https://guides.hexlet.io/logging</id><content type="html" xml:base="https://guides.hexlet.io/logging/">&lt;p&gt;Известно, что программисты проводят много времени, отлаживая свои программы, пытаясь разобраться, почему они не работают — или работают неправильно. Когда говорят про отладку, обычно подразумевают либо отладочную печать, либо использование специальных программ – дебагеров. С их помощью отслеживается выполнение кода по шагам, во время которого видно, как меняется содержимое переменных. Эти способы хорошо работают в небольших программах, но в реальных приложениях быстро становятся неэффективными.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/logging/debugger.png&quot; alt=&quot;Дебагер JavaScript в WebStorm&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;сложность-реальных-приложений&quot;&gt;Сложность реальных приложений&lt;/h2&gt;

&lt;p&gt;Возьмем для примера типичный сайт. Что он в себя включает?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.hexlet.io/dns/&quot;&gt;DNS&lt;/a&gt;. Система трансляции имени сайта в ip-адрес сервера.&lt;/li&gt;
  &lt;li&gt;Веб-сервер. Программа, обслуживающая входящие запросы, перенаправляет их в код приложения и забирает от приложения данные для пользователей.&lt;/li&gt;
  &lt;li&gt;Физический сервер (или виртуальный) с его окружением. Включает в себя операционную систему, установленные и запущенные обслуживающие программы, например, мониторинг.&lt;/li&gt;
  &lt;li&gt;База данных. Внешнее хранилище, с которым связывается код приложения и обменивается информацией.&lt;/li&gt;
  &lt;li&gt;Само приложение. Помимо кода, который пишут программисты, приложение включает в себя сотни тысяч и миллионы строк кода сторонних библиотек. Кроме этого, код работает внутри фреймворка, у которого свои собственные правила обработки входящих запросов.&lt;/li&gt;
  &lt;li&gt;Фронтенд часть. Код, который выполняется в браузере пользователя. И системы сборки для разработки, например, &lt;a href=&quot;https://guides.hexlet.io/webpack/&quot;&gt;Webpack&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner&quot;&gt;
    &lt;a href=&quot;https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;Интенсив: Девопс для программистов. Вся база за 3 месяца
&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;И это только самый простой случай. Реальность же значительно сложнее: множество разноплановых серверов, системы кеширования (ускорения доступа), асинхронный код, очереди, внешние сервисы, облачные сервисы. Все это выглядит как многослойный пирог, внутри которого где-то работает нами написанный код. И этот код составляет лишь небольшую часть всего происходящего. Как в такой ситуации понять, на каком этапе был сбой, или все пошло не по плану? Для этого, как минимум, нужно определить, в каком слое произошла ошибка. Но даже это не самое сложное. Об ошибках в работающем приложении узнают не сразу, а уже потом, — когда ошибка случилась и, иногда, больше не воспроизводится.&lt;/p&gt;

&lt;h2 id=&quot;логирование&quot;&gt;Логирование&lt;/h2&gt;

&lt;p&gt;И для всего этого многообразия систем существует единое решение — логирование. В простейшем случае логирование сводится к файлу на диске, куда разные программы записывают (логируют) свои действия во время работы. Такой файл называют логом или журналом. Как правило, внутри лога одна строчка соответствует одному действию.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Формат: ip-address / date / HTTP-method / uri / response code / body size &lt;/span&gt;
173.245.52.110 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /my HTTP/1.1&quot;&lt;/span&gt; 200 46018
108.162.219.13 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /sockjs-node/244/gdt1vvwa/websocket HTTP/1.1&quot;&lt;/span&gt; 0 0
162.158.62.12 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /packs/css/application.css HTTP/1.1&quot;&lt;/span&gt; 304 0
162.158.62.84 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /packs/js/runtime-eb0a99abbe8cf813f110.js HTTP/1.1&quot;&lt;/span&gt; 304 0
108.162.219.111 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /packs/js/application-2cba5619945c4e5946f1.js HTTP/1.1&quot;&lt;/span&gt; 304 0
108.162.219.21 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /packs/js/0564a7b5d773bab52e53.js HTTP/1.1&quot;&lt;/span&gt; 304 0
108.162.219.243 - &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;19/Jan/2021:01:54:20 +0000] &lt;span class=&quot;s2&quot;&gt;&quot;GET /packs/js/6fb7e908211839fac06e.js HTTP/1.1&quot;&lt;/span&gt; 304 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Выше небольшой кусок лога веб-сервера Хекслета. Из него видно ip-адрес, с которого выполнялся запрос на страницу и какие ресурсы загружались, метод HTTP, ответ бекенда (кода) и размер тела ответа в HTTP. Очень важно наличие даты. Благодаря ей всегда можно найти лог за конкретный период, например на то время, когда возникла ошибка. Для этого логи &lt;a href=&quot;https://ru.hexlet.io/courses/cli-basics/lessons/grep/theory_unit&quot;&gt;грепают&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Выведет 4 минуты логов за 31 марта 2020 года с 19:31 по 19:35&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;31/Mar/2020:19:3[1-5]&quot;&lt;/span&gt; access.log
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Когда программисты только начинают свой путь, они, часто не зная причину ошибки, опускают руки и говорят «я не знаю, что случилось, и что делать». Опытный же разработчик всегда первым делом говорит «а что в логах?». Анализировать логи — один из базовых навыков в разработке. В любой непонятной ситуации нужно смотреть логи. Логи пишут все программы без исключения, но делают это по-разному и в разные места. Чтобы точно узнать, куда и как, нужно идти в документацию конкретной программы и читать соответствующий раздел документации. Вот несколько примеров:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.rubyonrails.org/debugging_rails_applications.html#the-logger&quot;&gt;Ruby On Rails (Ruby)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/3.1/topics/logging/&quot;&gt;Django (Python)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://laravel.com/docs/8.x/logging&quot;&gt;Laravel (PHP)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.1.18.RELEASE/reference/html/boot-features-logging.html&quot;&gt;Spring Boot (Java)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.fastify.io/docs/v2.0.x/Logging/&quot;&gt;Fastify (Node.js)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Многие программы логируют прямо в консоль, например Webpack показывает процесс и результаты сборки:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Сюда же выводятся ошибки, если они были&lt;/span&gt;
｢wds｣: Project is running at http://hexletdev4.com/
｢wds｣: webpack output is served from /packs/
｢wds｣: Content not from webpack is served from /root/hexlet/public/packs
｢wds｣: 404s will fallback to /index.html
｢wdm｣: assets by chunk 10.8 MiB &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;auxiliary name: application&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 115 assets
sets by path js/ 13.8 MiB
assets by path js/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.js 13.8 MiB 52 assets
assets by path js/pages/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.js 5.1 KiB
  asset js/pages/da223d3affe56711f31f.js 2.6 KiB &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;emitted] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;immutable] &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;name: pages/my_learning&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 1 related asset
  asset js/pages/04adacfdd660803b19f1.js 2.5 KiB &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;emitted] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;immutable] &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;name: pages/referral&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 1 related asset
sets by chunk 9.14 KiB &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;auxiliary &lt;span class=&quot;nb&quot;&gt;id &lt;/span&gt;hint: vendors&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Во фронтенде файлов нет, поэтому логируют либо прямо в консоль, либо к себе в бекенды (что сложно), либо в специализированные сервисы, такие как &lt;a href=&quot;https://logrocket.com/&quot;&gt;LogRocket&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;уровни-логирования&quot;&gt;Уровни логирования&lt;/h2&gt;

&lt;p&gt;Чем больше информации выводится в логах, тем лучше и проще отладка, но когда данных слишком много, то в них тяжело искать нужное. В особо сложных случаях логи могут генерироваться с огромной скоростью и в гигантских размерах. Работать в такой ситуации нелегко. Чтобы как-то сгладить ситуацию, системы логирования вводят разные уровни. Обычно это:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;debug&lt;/li&gt;
  &lt;li&gt;info&lt;/li&gt;
  &lt;li&gt;warning&lt;/li&gt;
  &lt;li&gt;error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Поддержка уровней осуществляется двумя способами. Во-первых, внутри самой программы расставляют вызовы библиотеки логирования в соответствии с уровнями. Если произошла ошибка, то логируем как &lt;em&gt;error&lt;/em&gt;, если это отладочная информация, которая не нужна в обычной ситуации, то уровень &lt;em&gt;debug&lt;/em&gt;.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Пример логирования внутри программы&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Логер: https://github.com/pinojs/pino&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buildLogger&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;pino&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;logger&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;buildLogger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* возможная конфигурация */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;тут что то полезное&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Во-вторых, во время запуска программы указывается уровень логирования, необходимый в конкретной ситуации. По умолчанию используется уровень &lt;em&gt;info&lt;/em&gt;, который используется для описания каких-то ключевых и важных вещей. При таком уровне будут выводиться и &lt;em&gt;warning&lt;/em&gt;, и &lt;em&gt;error&lt;/em&gt;. Если поставить уровень &lt;em&gt;error&lt;/em&gt;, то будут выводиться только ошибки. А если &lt;em&gt;debug&lt;/em&gt;, то мы получим лог, максимально наполненный данными. Обычно &lt;em&gt;debug&lt;/em&gt; приводит к многократному росту выводимой информации.&lt;/p&gt;

&lt;p&gt;Уровни логирования, обычно, выставляются через переменную окружения во время запуска программы. Например, так:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# https://github.com/fastify/fastify-cli#options&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;FASTIFY_LOG_LEVEL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;debug fastify-server.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Существует и другой подход, основанный не на уровнях, а на пространствах имен. Этот подход получил широкое распространение в JS-среде, и является там основным. Фактически, он построен вокруг одной единственной библиотеки &lt;a href=&quot;https://github.com/visionmedia/debug&quot;&gt;debug&lt;/a&gt; для логирования, которой пронизаны практически все JavaScript-библиотеки как на фронтенде, так и на бекенде.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/logging/debug.png&quot; alt=&quot;Библиотека debug в JavaScript&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Принцип работы здесь такой. Под нужную ситуацию создается специализированная функция логирования с указанием пространства имен, которая затем используется для всех событий одного процесса. В итоге библиотека позволяет легко отфильтровать только нужные записи, соответствующие нужному пространству.&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;debug&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Пространство имен http&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;logHttp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;logSomethingElse&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;another-namespace&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Где-то в коде&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;logHttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* информация о http запросе */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Запуск с нужным пространством:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;DEBUG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http server.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/logging/debug-http.png&quot; alt=&quot;Библиотека debug для логирования http в JavaScript&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ротация-логов&quot;&gt;Ротация логов&lt;/h2&gt;

&lt;p&gt;Со временем количество логов становится большим, и с ними нужно что-то делать. Для этого используется ротация логов. Иногда за это отвечает сама программа, но чаще — внешнее приложение, задачей которого является чистка. Эта программа по необходимости разбивает логи на более мелкие файлы, сжимает, перемещает и, если нужно, удаляет. Подобная система встроена в любую операционную систему для работы с логами самой системы и внешних программ, которые могут встраиваться в нее.&lt;/p&gt;

&lt;p&gt;С веб-сайтами все еще сложнее. Даже на небольших проектах используется несколько серверов, на каждом из которых свои логи. А в крупных проектах тысячи серверов. Для управления такими системы созданы специализированные программы, которые следят за логами на всех машинах, скачивают их, складывают в заточенные под логи базы данных и предоставляют удобный способ поиска по ним.&lt;/p&gt;

&lt;p&gt;Здесь тоже есть несколько путей. Можно воспользоваться готовыми решениями, такими как &lt;a href=&quot;https://docs.datadoghq.com/logs/&quot;&gt;DataDog Logging&lt;/a&gt;, либо устанавливать и настраивать все самостоятельно через, например, &lt;a href=&quot;https://www.elastic.co/elastic-stack&quot;&gt;ELK Stack&lt;/a&gt;&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Известно, что программисты проводят много времени, отлаживая свои программы, пытаясь разобраться, почему они не работают — или работают неправильно. Когда говорят про отладку, обычно подразумевают либо отладочную печать, либо использование специальных программ – дебагеров. С их помощью отслеживается выполнение кода по шагам, во время которого видно, как меняется содержимое переменных. Эти способы хорошо работают в небольших программах, но в реальных приложениях быстро становятся неэффективными.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/logging/cover.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/logging/cover.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое компилятор?</title><link href="https://guides.hexlet.io/compiler/" rel="alternate" type="text/html" title="Что такое компилятор?" /><published>2020-10-28T00:00:00+00:00</published><updated>2020-10-28T00:00:00+00:00</updated><id>https://guides.hexlet.io/compiler</id><content type="html" xml:base="https://guides.hexlet.io/compiler/">&lt;p&gt;В этом гайде вы узнаете о том, что такое компилятор и как он работает. Мы разберем этапы компиляции и от чего зависит выбор подходящего компилятора. Этот материал поможет лучше понять, как компьютер выполняет программный код и почему иногда код не компилируется.&lt;/p&gt;

&lt;h2 id=&quot;зачем-нужен-компилятор&quot;&gt;Зачем нужен компилятор?&lt;/h2&gt;

&lt;p&gt;Процессор — самая важная часть компьютера. Он обрабатывает информацию, выполняет команды пользователя и следит за работой всех подключенных устройств. Но процессор может разобрать только машинный код — набор 0 и 1, которые записаны в определённом порядке.&lt;/p&gt;

&lt;p&gt;Почему именно 0 и 1? В процессор поступают электрические сигналы. Сильный сигнал обозначается цифрой 1, а слабый — 0. Набор таких цифр обозначает какую-то команду. Процессор ее распознает и выполняет.&lt;/p&gt;

&lt;div class=&quot;fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner&quot;&gt;
    &lt;a href=&quot;https://ru.hexlet.io/programs/java?utm_source=hexlet-guides&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;Профессия «Java-разработчик» с нуля и до трудоустройства
&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Программы для первых компьютеров выглядели как огромные наборы 0 и 1. Чтобы записать такую программу, инженеры пользовались гибкими картонными карточками — перфокартами. Цифры на перфокарте записывались поочередно, в несколько строк. Чтобы записать 1, программист делал отверстие в карте. Места без отверстия обозначали 0.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/compiler/card.png&quot; alt=&quot;Изображение перфокарты&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Компьютер считывал перфокарту специальным устройством и выполнял записанную команду. Для одной программы составляли сотни перфокарт.&lt;/p&gt;

&lt;p&gt;Писать их было долго и сложно, поэтому инженеры стали создавать языки программирования, обозначая команды словами и знаками. Для того, чтобы процессор понимал, какие команды записаны в программе, программисты создали &lt;strong&gt;компилятор&lt;/strong&gt; — программу, которая преобразует программный код в машинный.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/compiler/compiler.jpg&quot; alt=&quot;Схема преобразования програмного кода в бинарный&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;как-работает-компилятор&quot;&gt;Как работает компилятор?&lt;/h2&gt;

&lt;p&gt;Преобразование программного кода в машинный называется &lt;em&gt;компиляцией&lt;/em&gt;. Компиляция только преобразует код. Она не запускает его на исполнение. В этот момент он “статически” (то есть без запуска) транслируется в машинный код. Это сложный процесс, в котором сначала текст программы разбирается на части и анализируется, а затем генерируется код, понятный процессору.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/compiler/compilation_steps.jpg&quot; alt=&quot;Этапы компиляции&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Разберём этапы компиляции на примере вычисления периметра прямоугольника:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt; 
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Width of the rectangle - %4.1f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// =&amp;gt; Width of the rectangle - 2.5&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Length of the rectangle - %4.1f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// =&amp;gt; Length of the rectangle - 5.0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Perimeter of the rectangle is %4.1f&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// =&amp;gt; Perimeter of the rectangle is 15.0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;После запуска программы компилятору нужно определить, какие команды в ней записаны. Сначала компилятор разделяет программу на слова и знаки — &lt;em&gt;токены&lt;/em&gt;, и записывает их в список. Такой процесс называется &lt;strong&gt;лексическим анализом&lt;/strong&gt;. Его главная задача — получить токены.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;# include &amp;lt;iostream&amp;gt; int main ( ) { double a = 2.5 , b = 5 , P ;  P = 2 * ( a + b ) ; printf ( &quot; Width of the rectangle - % 4.1 f &quot; , a ) ; printf ( &quot; \ n Length of the rectangle - % 4.1 f &quot; , b ) ; printf ( &quot; \ n Perimeter of the rectangle is % 4.1 f &quot; ,   P ) ; return 0 ; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Затем компилятор читает список и ищет токен-операторы. Это могут быть оператор присваивания(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt;), арифметические операторы(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt;), оператор вывода(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;printf()&lt;/code&gt;) и другие операторы языка программирования. Такие операторы работают с числами, текстом и переменными.&lt;/p&gt;

&lt;p&gt;Компилятор должен понять, какие токены в списке связаны с токен-оператором. Чтобы сделать это правильно, для каждого оператора строится специальная структура — &lt;strong&gt;логическое дерево&lt;/strong&gt; или &lt;strong&gt;дерево разбора&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Так операция &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P = 2*(a + b)&lt;/code&gt; будет преобразована в логическое дерево:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/compiler/parse_tree.jpg&quot; alt=&quot;Дерево разбора&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Теперь каждое дерево нужно разобрать на команды, и каждую команду преобразовать в &lt;strong&gt;машинный код&lt;/strong&gt;. 
Компилятор начинает читать дерево снизу вверх и составляет список команд:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Взять переменную &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;, взять переменную &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;, сложить их&lt;/li&gt;
  &lt;li&gt;Взять результат сложения, взять число &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; и найти их произведение&lt;/li&gt;
  &lt;li&gt;Результат произведения присвоить (записать) в переменную &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Компилятор еще раз проверяет команды, находит ошибки и старается улучшить код. При успешном завершении этого этапа, компилятор переводит каждую команду в набор 0 и 1. Наборы записываются в файл, который сможет прочитать и выполнить процессор.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;10111011 00010001 00000001 10111001 00001101 00000000 10110100 00001110 10001010 00000111 01000011 11001101 00010000 11100010 11111001 11001101 00100000 01001000 01100101 01101100 01101100 01101111 00101100 00100000 01010111 01101111 01110010 01101100 01100100 00100001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;на-чем-написан-компилятор&quot;&gt;На чем написан компилятор?&lt;/h2&gt;

&lt;p&gt;В 1950-е годы группа разработчиков IBM под руководством Джона Бэкуса разработала первый высокоуровневый язык программирования &lt;a href=&quot;https://ru.wikipedia.org/wiki/Фортран&quot;&gt;Fortran&lt;/a&gt;, который позволил писать программы на понятном человеку языке. Помимо языка, инженеры работали и над компилятором. Он представлял собой программу с набором исполняемых команд, которая могла компилировать другие программы на Fortran, в том числе и улучшенную версию себя.&lt;/p&gt;

&lt;p&gt;В дальнейшем язык Fortran и его компилятор использовали, чтобы написать компиляторы для новых языков программирования. Такой подход используют программисты и в настоящее время. 
Писать машинный код долго и неудобно. К тому же, для современных процессоров он может отличаться. Придется писать несколько версий одного и того же компилятора для разных компьютеров. Быстрее и проще написать компилятор на существующем языке программирования. Для этого разработчики выбирают удобный язык и пишут на нем первую версию своего компилятора. Он будет более универсальным для компьютеров и легко скомпилирует улучшенную версию себя.
&lt;img src=&quot;/assets/images/compiler/create_compiler.jpg&quot; alt=&quot;Этапы создания компилятора&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;какие-бывают-компиляторы&quot;&gt;Какие бывают компиляторы?&lt;/h2&gt;

&lt;p&gt;Ни один компилируемый язык программирования не обходится без компилятора. Некоторые компиляторы работают с несколькими языками программирования. Но программист должен учитывать еще и параметры компьютера, на котором программа будет запускаться.&lt;/p&gt;

&lt;p&gt;Дело в том, что современные процессоры отличаются друг от друга устройством, поэтому машинный код для одного процессора будет понятен, а для другого нет. Это касается и операционных систем: одна и та же программа будет работать на Windows, но не запустится на Linux или MacOS. Поэтому нужно пользоваться тем компилятором, который работает с нужным процессором и операционной системой.&lt;/p&gt;

&lt;p&gt;Если программа будет работать на нескольких операционных системах, то нужен кросс-компилятор — компилятор, который преобразует универсальный машинный код. Например, GNU Compiler Collection(сокращенно GCC) поддерживает C++, Objective-C, Java, Фортран, Ada, Go и поддерживает разную архитектуру процессоров.&lt;/p&gt;

&lt;p&gt;Начинающие программисты даже не знают о наличии компилятора на компьютере. Они пишут программы в интегрированной среде разработки, в которую встроен компилятор, а иногда и не один. В этом случае, выбор компилятора делает среда, а не программист. Например, MS Visual Studio поддерживает компиляторы для операционных систем Windows, Linux, Android. Выбирая тип проекта, Visual Studio определяет процессор и операционную систему компьютера, и после этого выбирает подходящий компилятор.&lt;/p&gt;

&lt;h2 id=&quot;какие-ошибки-может-определить-компилятор&quot;&gt;Какие ошибки может определить компилятор?&lt;/h2&gt;

&lt;p&gt;Когда компилятор анализирует текст программы, он проверяет, соответствует ли запись оператора стандартам языка. Если найдено несоответствие, то компилятор выводит об этом информацию пользователю в виде &lt;em&gt;ошибки&lt;/em&gt;. Когда вся программа разобрана, пользователь видит список ошибок, которые есть в коде, и может их исправить. 
Пока программист не исправит ошибки, компилятор не перейдет к следующему этапу — генерации машинного кода для процессора.
Чаще всего компилятор показывает пользователю:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ошибки объявления переменных или отсутствие их начальных значений&lt;/li&gt;
  &lt;li&gt;ошибки несоответствия типов&lt;/li&gt;
  &lt;li&gt;ошибки неправильной записи операторов и функций&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Иногда компилятор определяет код, который при выполнении дает неправильный результат. Но преобразовать такую программу в машинный код все-таки можно. В этом случае компилятор показывает пользователю &lt;em&gt;предупреждение&lt;/em&gt;. Такая реакция компилятора больше похожа на рекомендации, но на них стоит обратить внимание. Программист сам решает оставить код с предупреждением или изменить программу.
Анализируя текст программы, компилятор не только ищет ошибки, но еще и упрощает ее код. Такой процесс называется оптимизацией.
Во время оптимизации компилятор изменяет программный код, но функции, которые выполняла программа, остаются прежними.&lt;/p&gt;

&lt;h2 id=&quot;выводы-и-рекомендации&quot;&gt;Выводы и рекомендации&lt;/h2&gt;

&lt;p&gt;Компилятор — переводчик между программистом и процессором. Он преобразует текст программы в машинный код, определяет ряд ошибок в программе и оптимизирует ее работу.
Выбирая, где компилировать программу, важно помнить о том, что машинный код для процессоров и операционных систем будет разным, и подобрать правильный компилятор.
Чем точнее компилятор определит команды, тем корректнее и быстрее будет работать программа. Для этого следуйте простым рекомендациям:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;использовать простые, понятные команды;&lt;/li&gt;
  &lt;li&gt;помнить о соответствии типов данных;&lt;/li&gt;
  &lt;li&gt;внимательно набирать код, избегая синтаксических ошибок;&lt;/li&gt;
  &lt;li&gt;избегать повторяющихся действий и бесполезных переменных.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;дополнительные-материалы&quot;&gt;Дополнительные материалы&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ru.wikipedia.org/wiki/Компилятор&quot;&gt;Компилятор&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://habr.com/ru/company/droider/blog/519732/&quot;&gt;ARM против x86: В чем разница между двумя архитектурами процессоров?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Татьяна Федорина</name></author><summary type="html">В этом гайде вы узнаете о том, что такое компилятор и как он работает. Мы разберем этапы компиляции и от чего зависит выбор подходящего компилятора. Этот материал поможет лучше понять, как компьютер выполняет программный код и почему иногда код не компилируется.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/compiler/compiler.jpg" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/compiler/compiler.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое Makefile и как начать его использовать</title><link href="https://guides.hexlet.io/makefile-as-task-runner/" rel="alternate" type="text/html" title="Что такое Makefile и как начать его использовать" /><published>2020-07-30T00:00:00+00:00</published><updated>2020-07-30T00:00:00+00:00</updated><id>https://guides.hexlet.io/makefile-as-task-runner</id><content type="html" xml:base="https://guides.hexlet.io/makefile-as-task-runner/">&lt;h2 id=&quot;введение&quot;&gt;Введение&lt;/h2&gt;

&lt;p&gt;В жизни многих разработчиков найдётся история про первый рабочий день с новым проектом. После клонирования основного репозитория проекта наступает этап, когда приходится вводить множество команд с определёнными флагами и в заданной последовательности. Без описания команд, в большинстве случаев, невозможно понять что происходит, например:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;touch&lt;/span&gt; ~/.bash_history
ufw allow 3035/tcp &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;cant configure ufw&apos;&lt;/span&gt;
ufw allow http &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;cant configure ufw&apos;&lt;/span&gt;
docker run &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /root/:/root/ &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /etc:/etc &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /var/run/docker.sock:/var/run/docker.sock &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /var/tmp:/var/tmp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; /tmp:/tmp &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$PWD&lt;/span&gt;:/app &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--network&lt;/span&gt; host &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;-w&lt;/span&gt; /app &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;--env-file&lt;/span&gt; .env &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  ansible ansible-playbook ansible/development.yml &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; ansible/development &lt;span class=&quot;nt&quot;&gt;--limit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;localhost &lt;span class=&quot;nt&quot;&gt;-vv&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qxF&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;fs.inotify.max_user_watches=524288&apos;&lt;/span&gt; /etc/sysctl.conf &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo &lt;/span&gt;fs.inotify.max_user_watches&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;524288 | &lt;span class=&quot;nb&quot;&gt;tee&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; /etc/sysctl.conf &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;cant set max_user_watches&apos;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; sysctl &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl daemon-reload &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эти команды являются лишь частью того, что необходимо выполнить при разворачивании проекта. В приведённом примере видно, что команды сами по себе длинные, содержат много флагов, а значит, их трудно не только запомнить, но и вводить вручную. Постоянно вести документацию становится сложнее с ростом проекта, она неизбежно устаревает, а порог входа для новичков становится выше, ведь уже никто не в состоянии вспомнить всех деталей проекта. Некоторые такие команды необходимо использовать каждый день, и даже не один раз в день.&lt;/p&gt;

&lt;div class=&quot;fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner&quot;&gt;
    &lt;a href=&quot;https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;Интенсив: Девопс для программистов. Вся база за 3 месяца
&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Со временем становится понятно, что нужен инструмент, способный объединить в себе подобные команды, предоставить к ним удобные шорткаты (&lt;em&gt;более короткие и простые команды&lt;/em&gt;) и обеспечить самодокументацию проекта. Именно таким инструментом стал &lt;em&gt;Makefile&lt;/em&gt; и утилита &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt;. Этот гайд расскажет, как использование этих инструментов позволит свести процесс разворачивания проекта к нескольким коротким и понятным командам:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
make setup
make start
make &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;что-такое-make-и-makefile&quot;&gt;Что такое &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; и &lt;em&gt;Makefile&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Makefile&lt;/em&gt; — это файл, который хранится вместе с кодом в репозитории. Его обычно помещают в корень проекта. Он выступает и как документация, и как исполняемый код. Мейкфайл скрывает за собой детали реализации и раскладывает “по полочкам” команды, а утилита &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; запускает их из того мейкфайла, который находится в текущей директории.&lt;/p&gt;

&lt;p&gt;Изначально &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; предназначалась для автоматизации сборки исполняемых программ и библиотек из исходного кода. Она поставлялась по умолчанию в большинство *nix дистрибутивов, что и привело к её широкому распространению и повсеместному использованию. Позже оказалось что данный инструмент удобно использовать и при разработке любых других проектов, потому что процесс в большинстве своём сводится к тем же задачам — автоматизация и сборка приложений.&lt;/p&gt;

&lt;p&gt;Применение мейка в проектах стало стандартом для многих разработчиков, включая крупные проекты. Примеры мейкфайла можно найти у таких проектов, как &lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/build/root/Makefile&quot;&gt;Kubernetes&lt;/a&gt;, &lt;a href=&quot;https://github.com/babel/babel/blob/main/Makefile&quot;&gt;Babel&lt;/a&gt;, &lt;a href=&quot;https://github.com/ansible/ansible/blob/devel/Makefile&quot;&gt;Ansible&lt;/a&gt; и, конечно же, повсеместно на &lt;a href=&quot;https://github.com/Hexlet&quot;&gt;Хекслете&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;синтаксис-makefile&quot;&gt;Синтаксис &lt;em&gt;Makefile&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; запускает цели из &lt;em&gt;Makefile&lt;/em&gt;, которые состоят из команд:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;цель1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; имя цели&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; поддерживается kebab-case и snake_case&lt;/span&gt;
	команда1 &lt;span class=&quot;c&quot;&gt;# для отступа используется табуляция, это важная деталь &lt;/span&gt;
	команда2 &lt;span class=&quot;c&quot;&gt;# команды будут выполняться последовательно и только в случае успеха предыдущей&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Но недостаточно просто начать использовать мейкфайл в проекте. Чтобы получить эффект от его внедрения, понадобится поработать над разделением команд на цели, а целям дать семантически подходящие имена. Поначалу, перенос команд в Makefile может привести к свалке всех команд в одну цель с «размытым» названием:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;up&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; разворачивание и запуск&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; .env.example .env
	&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;database/database.sqlite
	composer &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
	npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
	php artisan key:generate
	php artisan migrate &lt;span class=&quot;nt&quot;&gt;--seed&lt;/span&gt;
	heroku &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Procfile.dev &lt;span class=&quot;c&quot;&gt;# запуск проекта&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Здесь происходит сразу несколько действий: создание файла с переменными окружения, подготовка базы данных, генерация ключей, установка зависимостей и запуск проекта. Это невозможно понять из комментариев и названия цели, поэтому будет правильно разделить эти независимые команды на разные цели:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;env-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; создать .env-файл для секретов&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; .env.example .env

&lt;span class=&quot;nl&quot;&gt;sqlite-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; подготовить локальную БД&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;database/database.sqlite

&lt;span class=&quot;nl&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; установить зависимости&lt;/span&gt;
	composer &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
	npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; сгенерировать ключи&lt;/span&gt;
	php artisan key:generate

&lt;span class=&quot;nl&quot;&gt;db-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; загрузить данные в БД&lt;/span&gt;
	php artisan migrate &lt;span class=&quot;nt&quot;&gt;--seed&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; запустить приложение&lt;/span&gt;
	heroku &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Procfile.dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь, когда команды разбиты на цели, можно отдельно установить зависимости командой &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make install&lt;/code&gt; или запустить приложение через &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make start&lt;/code&gt;. Но остальные цели нужны только при первом разворачивании проекта и выполнять их нужно в определённой последовательности. Говоря языком мейкфайла, цель имеет пререквизиты:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;цель1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;цель2 &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; такой синтаксис указывает на зависимость задач — цель1 зависит от цель2&lt;/span&gt;
	команда2 &lt;span class=&quot;c&quot;&gt;# команда2 выполнится только в случае успеха команды из цель2&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;цель2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	команда1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Задачи будут выполняться только в указанной последовательности и только в случае успеха предыдущей задачи. Значит, можно добавить цель &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setup&lt;/code&gt;, чтобы объединить в себе все необходимые действия:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;env-prepare sqlite-prepare install key db-prepare &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; можно ссылаться на цели&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; описанные ниже&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;env-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; .env.example .env

&lt;span class=&quot;nl&quot;&gt;sqlite-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;touch &lt;/span&gt;database/database.sqlite

&lt;span class=&quot;nl&quot;&gt;install&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	composer &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
	npm &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	php artisan key:generate

&lt;span class=&quot;nl&quot;&gt;db-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	php artisan migrate &lt;span class=&quot;nt&quot;&gt;--seed&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	heroku &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Procfile.dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь развернуть и запустить проект достаточно двумя командами:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
make setup &lt;span class=&quot;c&quot;&gt;# выполнит последовательно: env-prepare sqlite-prepare install key db-prepare&lt;/span&gt;
make start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Благодаря проделанной работе &lt;em&gt;Makefile&lt;/em&gt;, команды проекта вместе с флагами сведены в &lt;em&gt;Makefile&lt;/em&gt;. Он обеспечивает правильный порядок выполнения и не важно, какие при этом задействованы языки и технологии.&lt;/p&gt;

&lt;h2 id=&quot;продвинутое-использование&quot;&gt;Продвинутое использование&lt;/h2&gt;

&lt;h3 id=&quot;фальшивая-цель&quot;&gt;Фальшивая цель&lt;/h3&gt;

&lt;p&gt;Использование &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; в проекте однажды может привести к появлению ошибки &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make: &amp;lt;имя-цели&amp;gt; is up to date.&lt;/code&gt;, хотя всё написано правильно. Зачастую, её появление связано с наличием каталога или файла, совпадающего с именем цели. Например:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt; цель в мейкфайле&lt;/span&gt;
	php artisan &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;Makefile
&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# в файловой системе находится каталог с именем, как у цели в мейкфайле&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# попытка запустить тесты&lt;/span&gt;
make: &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; is up to date.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Как уже говорилось ранее, изначально &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; предназначалась для сборок из исходного кода. Поэтому она ищет каталог или файл с указанным именем, и пытается собрать из него проект. Чтобы изменить это поведение, необходимо в конце мейкфайла добавить &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.PHONY&lt;/code&gt; указатель на цель:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	php artisan &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;.PHONY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
✓ All tests passed!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;последовательный-запуск-команд-и-игнорирование-ошибок&quot;&gt;Последовательный запуск команд и игнорирование ошибок&lt;/h3&gt;

&lt;p&gt;Запуск команд можно производить по одной: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make setup&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make start&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make test&lt;/code&gt; или указывать цепочкой через пробел: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make setup start test&lt;/code&gt;. Последний способ работает как зависимость между задачами, но без описания её в мейкфайле. Сложности могут возникнуть, если одна из команд возвращает ошибку, которую нужно игнорировать. В примерах ранее такой командой было создание .env-файла при разворачивании проекта:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;env-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; .env.example .env &lt;span class=&quot;c&quot;&gt;# если файл уже создан, то повторный запуск этой команды вернёт ошибку&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Самый простой (&lt;em&gt;но не единственный&lt;/em&gt;) способ «заглушить» ошибку — это сделать логическое ИЛИ прямо в мейкфайле:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;env-prepare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;cp&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; .env.example .env &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# теперь любой исход выполнения команды будет считаться успешным&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Добавлять такие хаки стоит с осторожностью, чтобы не «выстрелить себе в ногу» в более сложных случаях.&lt;/p&gt;

&lt;h3 id=&quot;переменные&quot;&gt;Переменные&lt;/h3&gt;

&lt;p&gt;Зачастую в команды подставляют параметры для конфигурации, указания путей, переменные окружения и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt; тоже позволяет этим управлять. Переменные можно прописать прямо в команде внутри мейкфайла и передавать их при вызове:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(HELLO)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make say &lt;span class=&quot;nv&quot;&gt;HELLO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;World
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;
Hello, World!

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make say &lt;span class=&quot;nv&quot;&gt;HELLO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Kitty
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, Kitty!&quot;&lt;/span&gt;
Hello, Kitty!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Переменные могут быть необязательными и содержать значение по умолчанию. Обычно их объявляют в начале мейкфайла.&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;HELLO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?=&lt;/span&gt;World &lt;span class=&quot;c&quot;&gt;# знак вопроса указывает, что переменная опциональна. Значение после присвоения можно не указывать.&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(HELLO)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;!&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Bash&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make say
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;
Hello, World!

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;make say &lt;span class=&quot;nv&quot;&gt;HELLO&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Kitty
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello, Kitty!&quot;&lt;/span&gt;
Hello, Kitty!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Некоторые переменные в &lt;em&gt;Makefile&lt;/em&gt; имеют названия отличные от системных. Например, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$PWD&lt;/code&gt; называется &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$CURDIR&lt;/code&gt; в &lt;a href=&quot;https://github.com/hexlet-basics/hexlet_basics/blob/3f4635bf629e2676efe547c9a01c22a2573eaebd/Makefile#L35-L39&quot;&gt;мейкфайле&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Makefile
&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;project-env-generate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	docker run &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;RUNNER_PLAYBOOK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ansible/development.yml &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$(CURDIR)&lt;/span&gt;/ansible/development:/runner/inventory &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$(CURDIR)&lt;/span&gt; - то же самое, что &lt;span class=&quot;nv&quot;&gt;$PWD&lt;/span&gt; в терминале
		&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;v &lt;span class=&quot;nv&quot;&gt;$(CURDIR)&lt;/span&gt;:/runner/project &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
		ansible/ansible-runner
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;заключение&quot;&gt;Заключение&lt;/h2&gt;

&lt;p&gt;В рамках данного гайда было рассказано об основных возможностях &lt;em&gt;Makefile&lt;/em&gt; и утилиты &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;make&lt;/code&gt;. Более плотное знакомство с данным инструментом откроет множество других его полезных возможностей: условия, циклы, подключение файлов. В компаниях, где имеется множество проектов, написанных разными командами в разное время, мейкфайл станет отличным подспорьем в стандартизации типовых команд: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setup start test deploy ...&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Возможность описывать в мейкфале последовательно многострочные команды позволяет использовать его как «универсальный клей» между менеджерами языков и другими утилитами. Широкая распространённость этого инструмента и общая простота позволяют внедрить его в свой проект достаточно легко, без необходимости доработок. Но мейкфайл может быть по-настоящему большим и сложным, это можно увидеть на примере реальных проектов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hexlet-codebattle/codebattle/blob/master/Makefile&quot;&gt;Codebattle&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/babel/babel/blob/main/Makefile&quot;&gt;Babel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/build/root/Makefile&quot;&gt;Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;дополнительные-материалы&quot;&gt;Дополнительные материалы&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ru.makefile.site/&quot;&gt;Руководство по современному Make&lt;/a&gt; — «выжимка» из документации на русском языке;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=pK9mF5aK05Q&quot;&gt;Утилита make: полезный универсальный инструмент программиста&lt;/a&gt; — видео-версия данного гайда.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Мейкфайлы, использованные при составлении гайда:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Hexlet/hexlet-sicp/blob/master/Makefile&quot;&gt;Hexlet SICP&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hexlet-basics/hexlet_basics/blob/master/Makefile&quot;&gt;Hexlet Basics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Введение</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/makefile/cover.jpg" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/makefile/cover.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Что такое “Менеджер версий”</title><link href="https://guides.hexlet.io/version_managers/" rel="alternate" type="text/html" title="Что такое “Менеджер версий”" /><published>2020-06-28T00:00:00+00:00</published><updated>2020-06-28T00:00:00+00:00</updated><id>https://guides.hexlet.io/version_managers</id><content type="html" xml:base="https://guides.hexlet.io/version_managers/">&lt;h2 id=&quot;системная-установка&quot;&gt;Системная установка&lt;/h2&gt;

&lt;p&gt;Для запуска кода на любом языке, необходимо установить его интерпретатор (или компилятор). В разных операционных системах это делается по-разному: где-то используются пакетные менеджеры, например, &lt;em&gt;apt&lt;/em&gt; или &lt;em&gt;yum&lt;/em&gt;, где-то скачивается установщик. Некоторые языки бывают предустановленны сразу, например, Python. На него многое завязано в дистрибутивах линукса.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Ubuntu&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;nodejs &lt;span class=&quot;c&quot;&gt;# установит не самую свежую версию&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Стандартный способ установки работает хорошо только в самом начале, когда происходит первичная настройка. Затем, с течением времени, начинают всплывать разные проблемы. Например, в какой-то момент выходит новая версия языка, которую нужно подключить к проекту. Обычно, должно пройти какое-то время, перед тем, как язык станет доступным для установки через пакетные менеджеры. И здесь либо придется ждать, что не всегда желательно, либо искать другой способ установки. Последнее нередко превращается в серьёзное испытание, с часами гугления и установкой дополнительных библиотек. Все это в конце концов засоряет систему и иногда ломает её.&lt;/p&gt;

&lt;div class=&quot;fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner&quot;&gt;
    &lt;a href=&quot;https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;Интенсив: Девопс для программистов. Вся база за 3 месяца
&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Другая серьёзная проблема – установка сразу нескольких версий одного языка. Такое бывает нужно, когда разработчик переключается между разными проектами, требующими разные версии. Насколько часто такое происходит? Крайне часто. Чем дальше в разработку, тем больше вариантов: разные проекты в компании, свои проекты, опенсорс.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Здесь нужно упомянуть, что всё это мало касается тех, кто целиком ушел в Docker и Docker Compose. Однако даже в этом случае, нужны языки для работы с опенсорсом.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;менеджеры-версий&quot;&gt;Менеджеры версий&lt;/h2&gt;

&lt;p&gt;Для решения этих проблем разработчики придумали менеджеры версий. Менеджер версий – это специальная программа, предназначенная для управления версиями языка. С его помощью устанавливают нужные версии и производят переключение между ними. В отличие от пакетных менеджеров, входящих в операционные системы, менеджеры версий всегда позволяют ставить последние версии языков, как только они выходят (включая установку альфа- и бета-версий).&lt;/p&gt;

&lt;p&gt;Например, для Node.js это &lt;a href=&quot;https://github.com/nvm-sh/nvm&quot;&gt;NVM&lt;/a&gt; (Node Version Manager):&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Установка NVM&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-o-&lt;/span&gt; https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
&lt;span class=&quot;c&quot;&gt;# Установка не означает активацию. После установки активной останется та версия, что и была до установки&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;node &lt;span class=&quot;c&quot;&gt;# Установка последней доступной версии ноды&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;6.14.4 &lt;span class=&quot;c&quot;&gt;# или 10.10.0, 8.9.1, и т.п.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm ls-remote &lt;span class=&quot;c&quot;&gt;# список доступных версий&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm use node &lt;span class=&quot;c&quot;&gt;# Активация последней установленной версии ноды&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm use node 14.1 &lt;span class=&quot;c&quot;&gt;# Активация нужной версии&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Для упрощения работы менеджеры версий обычно позволяют создать специальный файл внутри проекта, который зафиксирует нужную версию языка. В некоторых случаях менеджеры версий сами отслеживают этот файл и переключают версию автоматически.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;14.1&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; .nvmrc
&lt;span class=&quot;c&quot;&gt;# Эта команда увидела файл .nvmrc и использовала указанную там версию&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;nvm use
Found &lt;span class=&quot;s1&quot;&gt;&apos;/path/to/project/.nvmrc&apos;&lt;/span&gt; with version &amp;lt;14.1&amp;gt;
Now using node v14.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В современном мире сложно представить себе язык, у которого бы не было менеджера версий. Более того некоторые языки, такие как Ruby, имеют множество разных менеджеров версий, которые конкурируют между собой:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;go: gvm, g&lt;/li&gt;
  &lt;li&gt;java: jabba&lt;/li&gt;
  &lt;li&gt;ruby: rbenv, rvm, chruby&lt;/li&gt;
  &lt;li&gt;php: phpenv, phpbrew&lt;/li&gt;
  &lt;li&gt;python: pyenv&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Менеджеры версий позволили решить ещё несколько важных задач. Как правило, когда программист взаимодействует с языком, установленным напрямую, то ему приходится использовать &lt;em&gt;sudo&lt;/em&gt; при установке глобальных пакетов. Дело в том, что стандартная схема установки языка предназначена для всех пользователей сразу. Поэтому все нужные файлы, включая глобальные пакеты, попадают в общие директории для которых нужны права администратора. С точки зрения безопасности это довольно большая дыра, которой могут воспользоваться (и иногда пользуются) разработчики опенсорс библиотек. Менеджеры версий устанавливают всё в домашнюю директорию текущего пользователя, где у него и так полные права. С одной стороны это позволяет не запускать установку пакетов от имени администратора, а с другой — не засоряется система. Удалить язык и все его пакеты через менеджер версий невероятно просто. Достаточно стереть директорию (правда, лучше это делать средствами самого менеджера версий).&lt;/p&gt;

&lt;h2 id=&quot;универсальный-менеджер&quot;&gt;Универсальный менеджер&lt;/h2&gt;

&lt;p&gt;Решив одни проблемы, менеджеры версий добавили другие. Во-первых, их слишком много, и они иногда меняются, сначала популярен один, затем другой. Во-вторых, сам процесс установки менеджера версий может оказаться сложнее установки языка. Проблема в том, что им нужно быть универсальными и работать везде, что крайне проблематично, учитывая разнообразие современных экосистем. Достаточно посмотреть размер документации NVM, чтобы оценить масштаб катастрофы. В-третьих, все эти менеджеры работают по-разному и имеют разные команды. Из-за этого усложняется процесс переключения между ними при работе с разными языками.&lt;/p&gt;

&lt;p&gt;Всё это привело к следующему логическому шагу. В конце концов появился универсальный менеджер &lt;a href=&quot;https://asdf-vm.com/&quot;&gt;asdf&lt;/a&gt;, который, благодаря плагинам, способен работать с любыми языками. Неполный список его преимуществ:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Одна единственная утилита командной строки для работы со всеми языками&lt;/li&gt;
  &lt;li&gt;Единый интерфейс взаимодействия для всех языков&lt;/li&gt;
  &lt;li&gt;Автоматическое переключение на нужную версию языка внутри каждого проекта&lt;/li&gt;
  &lt;li&gt;Простая система плагинов, позволяющая добавить любые языки&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Сейчас &lt;em&gt;asdf&lt;/em&gt; набрал достаточно большую популярность и постепенно заменяет собой все остальные менеджеры версий (технически под капотом там часто используются менеджеры, специфические для конкретных языков). У него чуть более сложная система команд из-за необходимости поддерживать множество языков, но в остальном он резко упрощает весь процесс.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# У asdf прекрасная документация, где наглядно показано, как его установить,&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# и какие могут понадобится зависимости в разных системах&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Установка&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone https://github.com/asdf-vm/asdf.git ~/.asdf &lt;span class=&quot;nt&quot;&gt;--branch&lt;/span&gt; v0.7.8

&lt;span class=&quot;c&quot;&gt;# Для работы с конкретным языком, сначала нужно подключить соответствующий плагин&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Список доступных плагинов есть на сайте проекта&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;asdf plugin add nodejs

&lt;span class=&quot;c&quot;&gt;# Установка языка&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Вместо nodejs нужно подставить название того плагина, с которым работаем&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;asdf &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;nodejs latest &lt;span class=&quot;c&quot;&gt;# latest означает последнюю версию указанного языка&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Установка указанной версии&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;asdf &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;nodejs 14.1

&lt;span class=&quot;c&quot;&gt;# Установка нужной версии языка версией по умолчанию&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Здесь нужно всегда указывать конкретную версию&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;asdf global nodejs 14.1

&lt;span class=&quot;c&quot;&gt;# Показывает текущие версии для языков, установленных через asdf&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;asdf current
elixir         1.10.1-otp-22 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
erlang         22.2.7   &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
nodejs         14.2.0   &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
php            7.4.5    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
python         3.8.2 2.7.16 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
ruby           2.7.0    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
yarn           1.22.4   &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;by /Users/user/.tool-versions&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;вывод&quot;&gt;Вывод&lt;/h2&gt;

&lt;p&gt;Работа с разными версиями языков – непростая задача, которую решают менеджеры версий и докер (для продвинутых). Среди всех менеджеров выделяется &lt;em&gt;asdf&lt;/em&gt;, который становится универсальным инструментом для управления любыми языками и даже обычными программами.&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">Системная установка</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/version-manager/nvm.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/version-manager/nvm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Зачем нужно собирать фронтенд</title><link href="https://guides.hexlet.io/webpack/" rel="alternate" type="text/html" title="Зачем нужно собирать фронтенд" /><published>2020-06-27T00:00:00+00:00</published><updated>2020-06-27T00:00:00+00:00</updated><id>https://guides.hexlet.io/webpack</id><content type="html" xml:base="https://guides.hexlet.io/webpack/">&lt;p&gt;HTML поддерживает два способа работы с JavaScript. Первый – код добавляется прямо на страницу и второй – код загружается из файла указанного в теге &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;инлайновые-скрипты&quot;&gt;Инлайновые скрипты&lt;/h2&gt;

&lt;p&gt;Первый способ:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHTML&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello JavaScript!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Он работает только в самых простых ситуациях. Иногда им пользуются для добавления небольших интерактивных элементов, таких как переключатели табов, автокомплиты и т.п.&lt;/p&gt;

&lt;h2 id=&quot;код-в-файлах&quot;&gt;Код в файлах&lt;/h2&gt;

&lt;p&gt;Современный фронтенд вышел далеко за пределы этих задач. Количество JavaScript кода во многих проектах достигает десяток и сотен тысяч строк кода. Такую массу кода физически невозможно поддерживать внутри HTML. Потому он располагается в отдельных файлах, которых может быть довольно много. Для их подключения используется второй способ:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!--
Когда браузер встречает тег `&amp;lt;script&amp;gt;` с указанием `src`,
он загружает указанный файл и исполняет его.
Так код получает доступ к содержимому страницы.
--&amp;gt;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Все определения внутри становятся глобальны и доступны для всех остальных скриптов --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/assets/script1.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/assets/script2.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Тег &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; был добавлен в HTML очень давно, задолго до появления современной версии языка с модулями. В те времена не существовало Node.js, пакетного менеджера и понятия “зависимости” (dependencies). Весь код писался в одном файле. Даже если файлов было несколько, они никак не были связаны друг с другом. Если попытаться использовать модули вместе с обычным тегом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt;, то браузер выдаст ошибку:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;Uncaught SyntaxError: Cannot use import statement outside a module
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В теории, код можно писать и без использования системы модулей, но этот способ невероятно трудозатратный и основывается на том, что все определения в коде глобальны (а значит, можно легко что-нибудь сломать, перетерев существующие определения). Придётся руками указывать все существующие файлы и загружать их в HTML, в строго определённом порядке. Подобное сейчас встречается только на сайтах, где фронтенд — это jquery с небольшим числом интерактивных элементов.&lt;/p&gt;

&lt;div class=&quot;fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner&quot;&gt;
    &lt;a href=&quot;https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;Интенсив: Девопс для программистов. Вся база за 3 месяца
&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Отсутствие модулей делает нормальную разработку невозможной. Нельзя работать с зависимостями, нельзя написать тесты, статический анализ кода отсутствует (невозможны переходы по определениям, подсказки).&lt;/p&gt;

&lt;h2 id=&quot;модули-в-браузере&quot;&gt;Модули в браузере&lt;/h2&gt;

&lt;p&gt;Проблема отсутствия модулей в браузере настолько важная, что в HTML5 ввели поддержку JavaScript-модулей. Достаточно в теге &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; добавить &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;type=&quot;module&quot;&lt;/code&gt;, как браузер начинает их понимать и загружать. Модули понимают практически все современные браузеры.&lt;/p&gt;

&lt;p&gt;В HTML:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;module&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/assets/index.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В JavaScript:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// index.js&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;./app.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// app.js&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello from module!&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Модули в браузере кардинально всё меняют и позволяют работать с JavaScript так, как это нужно, если бы не одно серьёзное “но”. Система модулей в браузере не умеет работать с зависимостями. Если мы решим установить, например, lodash, то попытка его импортировать завершится с ошибкой. Решить эту проблему на уровне браузеров невозможно. Браузер ничего не знает про файловую систему и того, что там происходит.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;Uncaught TypeError: Failed to resolve module specifier &quot;lodash&quot;.
Relative references must start with either &quot;/&quot;, &quot;./&quot;, or &quot;../&quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;сборщики-фронтенда&quot;&gt;Сборщики фронтенда&lt;/h2&gt;

&lt;p&gt;Эти проблемы полностью решают системы сборки. Кроме загрузки файлов, они решают множество других не менее важных задач. Фронтенд-разработка сильно опирается на различные пре- и пост-процессоры. Например, для современного JavaScript (и TypeScript) и многих фреймворков нужен Babel, который получает на вход исходный код проекта, преобразует его в код понятный браузеру. Только после этого его можно отдавать клиенту.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Указываем исходную директорию src&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# И директорию, в которую положить готовый код&lt;/span&gt;
babel src &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; dist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;То же самое касается CSS. Всё больше разработчиков используют SASS, который нужно транслировать в чистый CSS.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Указываем исходную директорию stylesheets&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# И директорию, в которую положить готовый CSS&lt;/span&gt;
sass &lt;span class=&quot;nt&quot;&gt;--update&lt;/span&gt; stylesheets dist/stylesheets
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Кроме этих задач, сборщики занимаются следующим:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Предоставляют единую команду для полной сборки фронтенда включая все его части.&lt;/li&gt;
  &lt;li&gt;Автоматически пересобирают фронтенд во время разработки. Делают это очень быстро благодаря использованию инкрементальной сборки (собирают только то, что поменялось).&lt;/li&gt;
  &lt;li&gt;Обеспечивают производительность. Минифицируют и сжимают код (в том числе удаляя неиспользуемый). Разбивают его максимально удобным для кеширования способом.&lt;/li&gt;
  &lt;li&gt;Выполняют любые преобразования, например, TypeScript =&amp;gt; JavaScript. Позволяют подключать пре- и пост-процессоры, настроить порядок их применения к выбранным файлам.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если выполнять эти задачи вручную, то подготовка кода к запуску в браузере станет занимать больше времени, чем сама разработка.&lt;/p&gt;

&lt;h2 id=&quot;webpack&quot;&gt;Webpack&lt;/h2&gt;

&lt;p&gt;Одним из первых сборщиков фронтенда стал Webpack. Сейчас он стандарт де-факто в среде фронтенда, хотя существуют и другие решения. Общий принцип работы вебпака такой. В проекте устанавливается сам вебпак и описывается его конфигурация. Эта конфигурация содержит все правила сборки: какие файлы брать, какие обработчики к ним применять и куда складывать результат. На выходе вебпак формирует файл или набор файлов, готовых для загрузки в браузер. Дальше он не участвует, использование этих файлов – задача программиста.&lt;/p&gt;

&lt;p&gt;Webpack поставляется как npm-библиотека и устанавливается в проект, обычно, в dev-зависимости, а для работы удобно использовать cli-утилиту:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;mkdir &lt;/span&gt;webpack-demo
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;webpack-demo
npm init &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt;
npm i &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; webpack webpack-cli @webpack-cli/init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь можно инициализировать новый вебпак-проект, который автоматически создаст все необходимые файлы и конфигурацию одной командой:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;npx webpack init &lt;span class=&quot;nt&quot;&gt;--auto&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Она предложит перезаписать &lt;em&gt;package.json&lt;/em&gt;, добавит в проект несколько зависимостей, создаст HTML и JS-файлы, а также создаст конфигурационный файл. Запуск этой же команды без флага &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--auto&lt;/code&gt; откроет интерактивный режим, где можно более тонко настроить будущее приложение.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;npx webpack init

Just found a &lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;.yo-rc.json&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;a parent directory.
Setting the project root at: /home/hexlet/webpack-demo
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;webpack-cli] 
ℹ INFO  For more information and a detailed description of each question, have a look at: https://github.com/webpack/webpack-cli/blob/master/INIT.md
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;webpack-cli] ℹ INFO  Alternatively, run &lt;span class=&quot;s2&quot;&gt;&quot;webpack(-cli) --help&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;usage info

? Will your application have multiple bundles? No
? Which will be your application entry point? src/index
? In which folder &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you want to store your generated bundles? dist
? Will you use one of the below JS solutions? ES6
? Will you use one of the below CSS solutions? No

&lt;span class=&quot;c&quot;&gt;# вывод об установке библиотек&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;webpack-cli] 
Congratulations! Your new webpack configuration file has been created!

You can now run npm run build to bundle your application!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Проект готов и теперь его можно запустить:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;syntax&quot;&gt;&lt;code&gt;npx webpack serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Эта команда соберёт приложение в режиме разработки, откроет браузер и отобразит содержимое HTML-файла, а в консоль выведется сообщение из &lt;em&gt;src/index.js&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/webpack/init-app.png&quot; alt=&quot;Запущенное в браузере Webpack-приложение&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Конфигурационный файл &lt;em&gt;webpack.config.js&lt;/em&gt; будет содержать несколько плагинов, необходимых для работы с HTML. Всё готово, чтобы написать своё первое фронтенд-приложение, используя Webpack!&lt;/p&gt;

&lt;p&gt;Лучший способ продолжить с ним работу — это читать &lt;a href=&quot;https://webpack.js.org/guides/getting-started/#basic-setup&quot;&gt;официальную документацию&lt;/a&gt; и изучить &lt;a href=&quot;https://github.com/hexlet-boilerplates/webpack-package&quot;&gt;Webpack Boilerplate&lt;/a&gt;, созданный Хекслетом.&lt;/p&gt;</content><author><name>Кирилл Мокевнин</name></author><summary type="html">HTML поддерживает два способа работы с JavaScript. Первый – код добавляется прямо на страницу и второй – код загружается из файла указанного в теге &amp;lt;script&amp;gt;.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://guides.hexlet.io/assets/images/webpack/webpack.png" /><media:content medium="image" url="https://guides.hexlet.io/assets/images/webpack/webpack.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>