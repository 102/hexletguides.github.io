# Что такое динамическое программирование?



Оглавление



## Мотивация

Наша работа состоит из решения головоломок. Многие из этих головоломок имеют эффективное решение, но некоторые возможно решить только перебором всех возможных вариантов. По крайней мере, именно такое впечатление складывается при ознакомлении с этими задачами. 

Решение полным перебором часто называют решением в лоб, методом грубой силы или наивным решением. Такие решения имеют очевидный минус — они очень затратны. Практические любое неоптимизированное решение перебором будет стоить экспоненциального времени, например O(2^n), где n — это количество элементов в нашей задаче. Такими элементами могут быть ячейки массива, узлы графа, разнообразные объекты из предметной области — всё, что угодно. 

Это очень плохое время работы. Настолько плохое, что никому и в голову не придёт запустить такой алгоритм даже на простых данных, ведь даже на решение такой задачи с сотней элементов потребуются тысячи, миллионы и миллиарды лет вычислений. А ведь в реальной жизни нужно решать задачи с намного большим количеством элементов. Как же быть?

Дело в том, что многие задачи без эффективного алгоритма решения можно решить за привлекательное время с помощью одного лайфхака. Имя ему — динамическое программирование! Но давайте обо всём по порядку…



## Динамическое программирование

Динамическое программирование это подход к решению задач. Основная его идея — оптимальное решение задачи можно собрать из решений её кусочков. В отличии от обычной рекурсии и решений по принципу “разделяй и властвуй”, решения задач в динамическом программировании скорее наращиваются с нуля, а не собираются из кусочков раздробленной исходной задачи.

Магия динамического программирования заключается в умном обращении с решениями подзадач. “Умный ” в этом контексте значит “не решающий одну и ту же проблему дважды”. Для этого решения мелких подзадач должны заботливо учитываться в подходящей структуре данных. Для многих реальных алгоритмов динамического программирования этой структурой данных является таблица. Обычная таблица, похожая на таблицы из Excel.

Думаю, что основной нюанс динамического программирования уже витает в воздухе — потребление памяти. И правда динамическое программирование творит чудеса скорости решения “нерешаемых ” задач, жертвуя потреблением памяти.

В самых простых случаях эта таблица будет состоять только из одной строки — аналогично обычному массиву. Эти случаи будут называться одномерным динамическим программированием, и потреблять O(n) памяти.

В самых распространённых случаях эта таблица будет выглядеть привычно, из строчек и столбиков. Это называется двумерным динамическим программированием, которое при n строках и n столбцах таблицы будет потреблять O(n*n) = O(n^2) памяти.

Бывают и более запутанные случаи, использующие трёхмерные таблицы, но это уже экзотика — O(n^3) памяти выглядит не сильно симпатичнее экспоненциального времени наивного решения.

Что нужно, чтоб решить задачу динамически, помимо её исходных данных? Всего три вещи:

- Таблица, в которую будут вноситься промежуточные результаты. Один из них будет выбран в конце работы алгоритма в качестве ответа.
- Несколько простых правил по заполнению пустых ячеек таблицы, основываясь на значениях в уже заполненных ячейках. Универсального рецепта тут нет, и к каждой задаче требуется свой подход.
- Правило выбора финального решения после заполнения таблицы.



## Пример решения задачи

Много слов уже было сказано о динамическом программировании, но всё ещё не стало понятно, что именно оно из себя представляет. Настало время наглядного примера.

Демонстрационным подопытным выступит классическая задача динамического программирования — Расстояние Левенштейна. Звучит немножко пугающе, но на самом деле это задача об эффективной трансформации одного слова в другое путём добавления, удаления и замены букв.



### Формулировка задачи

Не будем забираться в математическую формулировку, лучше сформулируем задачу на пальцах.  

Наша задача: найти минимальную разницу между двумя словами. Разницей в этом случае будет минимальное количество операций, которые нужно применить к первому слову, чтобы получить второе (или наоборот).

Доступных операции у нас три:

- insert — добавить одну букву в любое место в слове, в том числе в самое начало и в конец.
- delete — удалить одну букву из любого места в слове.
- replace — заменить одну букву на определённом месте на другую букву.

Все эти операции имеют равную стоимость: +1 к расстоянию.

Возьмем для примера два простых слова, MONEY и MONKEY. Какое минимальное количество операций необходимо, чтоб превратить MONEY в MONKEY? Находчивый человеческий глаз быстро смекнёт, что одна: добавить букву K после между третьей и четвертой буквой.

Кажется очень простой задачей, правда? Попробуйте превратить слово SATURDAY в слово SUNDAY, и вы увидите, что количество комбинаций, которые нужно перебрать, потенциально очень велико. Если решать задачу в лоб, то можно перебрать все возможные комбинации, рекурсивно применяя каждую операцию к каждой букве слова. Даже если по-умному подбирать буквы для replace, каждая буква в первом слове будет порождать три ветки рекурсии, что приведет нас аж к O(3^n) операций в худшем случае. 

### Динамическое решение

Приступим к динамическому решению!

Для начала, создадим таблицу, и разместим исходные слова на её краях, оставив немножко свободного места. Второй столбик и вторую строчку буем использовать для пустых строк — их часто обозначают символом ε, читается epsilon. Аналог того, что вы имеете ввиду, когда используете пустую строку на своём языке программирования: String eps = “”.

|       |  ε   |  S   |  A   |  T   |  U   |  R   |  D   |  A   |  Y   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **ε** |      |      |      |      |      |      |      |      |      |
| **S** |      |      |      |      |      |      |      |      |      |
| **U** |      |      |      |      |      |      |      |      |      |
| **N** |      |      |      |      |      |      |      |      |      |
| **D** |      |      |      |      |      |      |      |      |      |
| **A** |      |      |      |      |      |      |      |      |      |
| **Y** |      |      |      |      |      |      |      |      |      |

Теперь заполним второй столбик и вторую строчку, руководствуясь абсолютно интуитивными соображениями: как превратить пустую строку в какую-то строку? Конечно же, добавить в неё нужные символы! Например, чтоб перевести ε в SATU необходимо добавить букву S, букву A, букву T и букву U. Четыре операции. Что делать с превращением ε в ε (вторая строка, второй столбец)? Элементарно - ничего делать не нужно, ноль действий.

|       |  ε   |  S   |  A   |  T   |  U   |  R   |  D   |  A   |  Y   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| **ε** |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| **S** |  1   |      |      |      |      |      |      |      |      |
| **U** |  2   |      |      |      |      |      |      |      |      |
| **N** |  3   |      |      |      |      |      |      |      |      |
| **D** |  4   |      |      |      |      |      |      |      |      |
| **A** |  5   |      |      |      |      |      |      |      |      |
| **Y** |  6   |      |      |      |      |      |      |      |      |

Теперь нужна система простых правил, с помощью которой мы сможем заполнить таблицу. Таблица будет именоваться D, а первая строчка и столбик останутся на её полях. Работать с таблицей мы будем, как с двухмерным массивом: D[0, 2] означают ячейку на пересечении нулевой строки и второго столбика. В нашем примере D[0, 2] = 2.

Также назовём первое слово A, и его индексы будем сохранять в переменной i, а второе слово B с индексом j. Эта парочка нам нужна, чтоб иметь доступ к оригинальным словам на полях. Из-за дополнительных колонок в для ε индексы в A и B отличаются от индексов в таблице. Если быть точнее — они сдвинуты на единицу. A[0] = S, A[1] = A, A[2] = T, B[5] = Y, и так далее.

*TODO сделать картинкой:*

```
      D[i, j] = min(D[i-1, j] + 1,                              // delete
                    D[i, j-1] + 1,                              // insert 
                    D[i-1, j-1] + (A[i-1] == B[j-1] ? 1 : 0)    // replace 
                    )  
```

## Достоинства

- Скорость

- Элегантность


## Проблематика

- Память

- Контринтуитивность




## Области применения