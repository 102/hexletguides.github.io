<!doctype html>
<html amp lang="en">
  <head>
    <meta charset="utf-8">
    <script async src="https://cdn.ampproject.org/v0.js"></script>
    <title>Why and How to Use Docker?</title>
    <link rel="canonical" href="https://guides.hexlet.io/docker/" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script async custom-element="amp-analytics" src="https://cdn.ampproject.org/v0/amp-analytics-0.1.js"></script>

    
    <style amp-custom>
      .banner { background-color: #f8f9fa; border-left: 3px solid #0dcaf0; padding: 1rem; }

.markdown .banner a { text-decoration: none; }

.full_post_link.full_post_link { padding: .7rem 1rem; display: block; border: 1px solid #212529; border-radius: 2px; text-align: center; text-decoration: none; font-size: 1rem; }

.markdown { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; color: #4a5568; margin-left: auto; margin-right: auto; max-width: 65ch; padding: 3rem 1.5rem; }

.markdown [class~="lead"] { color: #4a5568; font-size: 1.25em; line-height: 1.6; margin-top: 1.2em; margin-bottom: 1.2em; }

.markdown a { color: #1a202c; text-decoration: underline; }

.markdown strong { color: #1a202c; font-weight: 600; }

.markdown ol { list-style: none; padding: 0; counter-reset: list-counter; margin-top: 1.25em; margin-bottom: 1.25em; }

.markdown ol > li { position: relative; counter-increment: list-counter; padding-left: 1.75em; }

.markdown ol > li::before { content: counter(list-counter) "."; position: absolute; font-weight: 400; color: #718096; }

.markdown ul > li { position: relative; padding-left: 1.75em; }

.markdown ul > li::before { content: ""; position: absolute; background-color: #cbd5e0; border-radius: 50%; width: 0.375em; height: 0.375em; top: calc(0.875em - 0.1875em); left: 0.25em; }

.markdown hr { border-color: #e2e8f0; border-top-width: 1px; margin-top: 3em; margin-bottom: 3em; }

.markdown blockquote { font-weight: 500; font-style: italic; color: #1a202c; border-left-width: 0.25rem; border-left-color: #e2e8f0; margin-top: 1.6em; margin-bottom: 1.6em; padding-left: 1em; }

.markdown blockquote p:first-of-type::before { content: open-quote; }

.markdown blockquote p:last-of-type::after { content: close-quote; }

.markdown h1 { color: #1a202c; font-weight: 800; font-size: 2.25em; margin-top: 0; margin-bottom: 0.8888889em; line-height: 1.1111111; }

.markdown h2 { color: #1a202c; font-weight: 700; font-size: 1.5em; margin-top: 2em; margin-bottom: 1em; line-height: 1.3333333; }

.markdown h3 { color: #1a202c; font-weight: 600; font-size: 1.25em; margin-top: 1.6em; margin-bottom: 0.6em; line-height: 1.6; }

.markdown h4 { color: #1a202c; font-weight: 600; margin-top: 1.5em; margin-bottom: 0.5em; line-height: 1.5; }

.markdown figure figcaption { color: #718096; font-size: 0.875em; line-height: 1.4285714; margin-top: 0.8571429em; }

.markdown code { color: #1a202c; font-weight: 600; font-size: 0.875em; }

.markdown code::before { content: "`"; }

.markdown code::after { content: "`"; }

.markdown pre { color: #e2e8f0; background-color: #2d3748; overflow-x: auto; font-size: 0.875em; line-height: 1.7142857; margin-top: 1.7142857em; margin-bottom: 1.7142857em; border-radius: 0.375rem; padding-top: 0.8571429em; padding-right: 1.1428571em; padding-bottom: 0.8571429em; padding-left: 1.1428571em; }

.markdown pre code { background-color: transparent; border-width: 0; border-radius: 0; padding: 0; font-weight: 400; color: inherit; font-size: inherit; font-family: inherit; line-height: inherit; }

.markdown pre code::before { content: ""; }

.markdown pre code::after { content: ""; }

.markdown table { width: 100%; table-layout: auto; text-align: left; margin-top: 2em; margin-bottom: 2em; font-size: 0.875em; line-height: 1.7142857; }

.markdown thead { color: #1a202c; font-weight: 600; border-bottom-width: 1px; border-bottom-color: #cbd5e0; }

.markdown thead th { vertical-align: bottom; padding-right: 0.5714286em; padding-bottom: 0.5714286em; padding-left: 0.5714286em; }

.markdown tbody tr { border-bottom-width: 1px; border-bottom-color: #e2e8f0; }

.markdown tbody tr:last-child { border-bottom-width: 0; }

.markdown tbody td { vertical-align: top; padding-top: 0.5714286em; padding-right: 0.5714286em; padding-bottom: 0.5714286em; padding-left: 0.5714286em; }

.markdown { font-size: 1rem; line-height: 1.75; }

.markdown p { margin-top: 1.25em; margin-bottom: 1.25em; }

.markdown img { margin-top: 2em; margin-bottom: 2em; }

.markdown video { margin-top: 2em; margin-bottom: 2em; }

.markdown figure { margin-top: 2em; margin-bottom: 2em; }

.markdown figure > * { margin-top: 0; margin-bottom: 0; }

.markdown h2 code { font-size: 0.875em; }

.markdown h3 code { font-size: 0.9em; }

.markdown ul { margin-top: 1.25em; margin-bottom: 1.25em; list-style: none; padding: 0; }

.markdown li { margin-top: 0.5em; margin-bottom: 0.5em; }

.markdown ol > li:before { left: 0; }

.markdown > ul > li p { margin-top: 0.75em; margin-bottom: 0.75em; }

.markdown > ul > li > *:first-child { margin-top: 1.25em; }

.markdown > ul > li > *:last-child { margin-bottom: 1.25em; }

.markdown > ol > li > *:first-child { margin-top: 1.25em; }

.markdown > ol > li > *:last-child { margin-bottom: 1.25em; }

.markdown ul ul, .markdown ul ol, .markdown ol ul, .markdown ol ol { margin-top: 0.75em; margin-bottom: 0.75em; }

.markdown hr + * { margin-top: 0; }

.markdown h2 + * { margin-top: 0; }

.markdown h3 + * { margin-top: 0; }

.markdown h4 + * { margin-top: 0; }

.markdown thead th:first-child { padding-left: 0; }

.markdown thead th:last-child { padding-right: 0; }

.markdown tbody td:first-child { padding-left: 0; }

.markdown tbody td:last-child { padding-right: 0; }

.markdown > :first-child { margin-top: 0; }

.markdown > :last-child { margin-bottom: 0; }

@media (min-width: 768px) { .md\:markdown-lg { font-size: 1.125rem; line-height: 1.7777778; } .md\:markdown-lg p { margin-top: 1.3333333em; margin-bottom: 1.3333333em; } .md\:markdown-lg [class~="lead"] { font-size: 1.2222222em; line-height: 1.4545455; margin-top: 1.0909091em; margin-bottom: 1.0909091em; } .md\:markdown-lg blockquote { margin-top: 1.6666667em; margin-bottom: 1.6666667em; padding-left: 1em; } .md\:markdown-lg h1 { font-size: 2.6666667em; margin-top: 0; margin-bottom: 0.8333333em; line-height: 1; } .md\:markdown-lg h2 { font-size: 1.6666667em; margin-top: 1.8666667em; margin-bottom: 1.0666667em; line-height: 1.3333333; } .md\:markdown-lg h3 { font-size: 1.3333333em; margin-top: 1.6666667em; margin-bottom: 0.6666667em; line-height: 1.5; } .md\:markdown-lg h4 { margin-top: 1.7777778em; margin-bottom: 0.4444444em; line-height: 1.5555556; } .md\:markdown-lg img { margin-top: 1.7777778em; margin-bottom: 1.7777778em; } .md\:markdown-lg video { margin-top: 1.7777778em; margin-bottom: 1.7777778em; } .md\:markdown-lg figure { margin-top: 1.7777778em; margin-bottom: 1.7777778em; } .md\:markdown-lg figure > * { margin-top: 0; margin-bottom: 0; } .md\:markdown-lg figure figcaption { font-size: 0.8888889em; line-height: 1.5; margin-top: 1em; } .md\:markdown-lg code { font-size: 0.8888889em; } .md\:markdown-lg h2 code { font-size: 0.8666667em; } .md\:markdown-lg h3 code { font-size: 0.875em; } .md\:markdown-lg pre { font-size: 0.8888889em; line-height: 1.75; margin-top: 2em; margin-bottom: 2em; border-radius: 0.375rem; padding-top: 1em; padding-right: 1.5em; padding-bottom: 1em; padding-left: 1.5em; } .md\:markdown-lg ol { margin-top: 1.3333333em; margin-bottom: 1.3333333em; } .md\:markdown-lg ul { margin-top: 1.3333333em; margin-bottom: 1.3333333em; } .md\:markdown-lg li { margin-top: 0.6666667em; margin-bottom: 0.6666667em; } .md\:markdown-lg ol > li { padding-left: 1.6666667em; } .md\:markdown-lg ol > li:before { left: 0; } .md\:markdown-lg ul > li { padding-left: 1.6666667em; } .md\:markdown-lg ul > li::before { width: 0.3333333em; height: 0.3333333em; top: calc(0.8888889em - 0.1666667em); left: 0.2222222em; } .md\:markdown-lg > ul > li p { margin-top: 0.8888889em; margin-bottom: 0.8888889em; } .md\:markdown-lg > ul > li > *:first-child { margin-top: 1.3333333em; } .md\:markdown-lg > ul > li > *:last-child { margin-bottom: 1.3333333em; } .md\:markdown-lg > ol > li > *:first-child { margin-top: 1.3333333em; } .md\:markdown-lg > ol > li > *:last-child { margin-bottom: 1.3333333em; } .md\:markdown-lg ul ul, .md\:markdown-lg ul ol, .md\:markdown-lg ol ul, .md\:markdown-lg ol ol { margin-top: 0.8888889em; margin-bottom: 0.8888889em; } .md\:markdown-lg hr { margin-top: 3.1111111em; margin-bottom: 3.1111111em; } .md\:markdown-lg hr + * { margin-top: 0; } .md\:markdown-lg h2 + * { margin-top: 0; } .md\:markdown-lg h3 + * { margin-top: 0; } .md\:markdown-lg h4 + * { margin-top: 0; } .md\:markdown-lg table { font-size: 0.8888889em; line-height: 1.5; } .md\:markdown-lg thead th { padding-right: 0.75em; padding-bottom: 0.75em; padding-left: 0.75em; } .md\:markdown-lg thead th:first-child { padding-left: 0; } .md\:markdown-lg thead th:last-child { padding-right: 0; } .md\:markdown-lg tbody td { padding-top: 0.75em; padding-right: 0.75em; padding-bottom: 0.75em; padding-left: 0.75em; } .md\:markdown-lg tbody td:first-child { padding-left: 0; } .md\:markdown-lg tbody td:last-child { padding-right: 0; } .md\:markdown-lg > :first-child { margin-top: 0; } .md\:markdown-lg > :last-child { margin-bottom: 0; } }

@media (min-width: 1024px) { .lg\:markdown-xl { font-size: 1.25rem; line-height: 1.8; } .lg\:markdown-xl p { margin-top: 1.2em; margin-bottom: 1.2em; } .lg\:markdown-xl [class~="lead"] { font-size: 1.2em; line-height: 1.5; margin-top: 1em; margin-bottom: 1em; } .lg\:markdown-xl blockquote { margin-top: 1.6em; margin-bottom: 1.6em; padding-left: 1.0666667em; } .lg\:markdown-xl h1 { font-size: 2.8em; margin-top: 0; margin-bottom: 0.8571429em; line-height: 1; } .lg\:markdown-xl h2 { font-size: 1.8em; margin-top: 1.5555556em; margin-bottom: 0.8888889em; line-height: 1.1111111; } .lg\:markdown-xl h3 { font-size: 1.5em; margin-top: 1.6em; margin-bottom: 0.6666667em; line-height: 1.3333333; } .lg\:markdown-xl h4 { margin-top: 1.8em; margin-bottom: 0.6em; line-height: 1.6; } .lg\:markdown-xl img { margin-top: 2em; margin-bottom: 2em; } .lg\:markdown-xl video { margin-top: 2em; margin-bottom: 2em; } .lg\:markdown-xl figure { margin-top: 2em; margin-bottom: 2em; } .lg\:markdown-xl figure > * { margin-top: 0; margin-bottom: 0; } .lg\:markdown-xl figure figcaption { font-size: 0.9em; line-height: 1.5555556; margin-top: 1em; } .lg\:markdown-xl code { font-size: 0.9em; } .lg\:markdown-xl h2 code { font-size: 0.8611111em; } .lg\:markdown-xl h3 code { font-size: 0.9em; } .lg\:markdown-xl pre { font-size: 0.9em; line-height: 1.7777778; margin-top: 2em; margin-bottom: 2em; border-radius: 0.5rem; padding-top: 1.1111111em; padding-right: 1.3333333em; padding-bottom: 1.1111111em; padding-left: 1.3333333em; } .lg\:markdown-xl ol { margin-top: 1.2em; margin-bottom: 1.2em; } .lg\:markdown-xl ul { margin-top: 1.2em; margin-bottom: 1.2em; } .lg\:markdown-xl li { margin-top: 0.6em; margin-bottom: 0.6em; } .lg\:markdown-xl ol > li { padding-left: 1.8em; } .lg\:markdown-xl ol > li:before { left: 0; } .lg\:markdown-xl ul > li { padding-left: 1.8em; } .lg\:markdown-xl ul > li::before { width: 0.35em; height: 0.35em; top: calc(0.9em - 0.175em); left: 0.25em; } .lg\:markdown-xl > ul > li p { margin-top: 0.8em; margin-bottom: 0.8em; } .lg\:markdown-xl > ul > li > *:first-child { margin-top: 1.2em; } .lg\:markdown-xl > ul > li > *:last-child { margin-bottom: 1.2em; } .lg\:markdown-xl > ol > li > *:first-child { margin-top: 1.2em; } .lg\:markdown-xl > ol > li > *:last-child { margin-bottom: 1.2em; } .lg\:markdown-xl ul ul, .lg\:markdown-xl ul ol, .lg\:markdown-xl ol ul, .lg\:markdown-xl ol ol { margin-top: 0.8em; margin-bottom: 0.8em; } .lg\:markdown-xl hr { margin-top: 2.8em; margin-bottom: 2.8em; } .lg\:markdown-xl hr + * { margin-top: 0; } .lg\:markdown-xl h2 + * { margin-top: 0; } .lg\:markdown-xl h3 + * { margin-top: 0; } .lg\:markdown-xl h4 + * { margin-top: 0; } .lg\:markdown-xl table { font-size: 0.9em; line-height: 1.5555556; } .lg\:markdown-xl thead th { padding-right: 0.6666667em; padding-bottom: 0.8888889em; padding-left: 0.6666667em; } .lg\:markdown-xl thead th:first-child { padding-left: 0; } .lg\:markdown-xl thead th:last-child { padding-right: 0; } .lg\:markdown-xl tbody td { padding-top: 0.8888889em; padding-right: 0.6666667em; padding-bottom: 0.8888889em; padding-left: 0.6666667em; } .lg\:markdown-xl tbody td:first-child { padding-left: 0; } .lg\:markdown-xl tbody td:last-child { padding-right: 0; } .lg\:markdown-xl > :first-child { margin-top: 0; } .lg\:markdown-xl > :last-child { margin-bottom: 0; } }

    </style>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
  </head>
  <body>
    <amp-analytics type="gtag" data-credentials="include">
<script type="application/json">
{
  "vars" : {
    "gtag_id": "UA-1360700-62",
    "config" : {
      "UA-1360700-62": { "groups": "default" }
    }
  }
}
</script>
</amp-analytics>

<amp-analytics type="metrika">
<script type="application/json">
{
    "vars": {
      "counterId": "65474386"
            },
   "triggers": {
        "notBounce": {
            "on": "timer",
            "timerSpec": {
                "immediate": false,
                "interval": 15,
                "maxTimerLength": 14
            },
            "request": "notBounce"
        }
    }
}
</script>
</amp-analytics>

    
    <div class="markdown md:markdown-lg lg:markdown-xl">
      <h1>Why and How to Use Docker?</h1>
      
      
      

      <a class="full_post_link" href="https://guides.hexlet.io/docker/">Читать в полной версии →</a>

      <p><strong>Docker is a program that allows the operating system to run processes in an isolated environment based on specially created images. And, while the technologies underlying Docker existed earlier, it was Docker that changed the way we now build project infrastructure, assemble and launch services.</strong></p>

<p><em>(Some details were purposefully left out of the article to avoid unnecessary information).</em></p>

<h2 id="installation">Installation</h2>

<p>To start with Docker, you must first install the Docker Engine. Download links for all popular platforms are provided at https://docs.docker.com/engine/install/. Select yours and install Docker.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>There’s one thing to remember when installing Docker on Mac and Linux. By default, Docker runs through a non-networked UNIX socket. For security reasons, the socket is blocked for users who are not members of the docker group. Although the installer automatically adds the current user to this group, Docker will not work straight away. In reality, changing the group by the user has no effect till the user logs in again. This is a feature of the core. Enter the <code class="language-plaintext highlighter-rouge">id</code> command to see which groups your user belongs to.</p>

<p>You can check if the installation was successful with the <code class="language-plaintext highlighter-rouge">docker info</code> command:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker info
Containers: 22
 Running: 2
 Paused: 0
 Stopped: 20
Images: 72
Server Version: 17.12.0-ce
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: <span class="nb">true
 </span>Native Overlay Diff: <span class="nb">true
</span>Logging Driver: json-file
Cgroup Driver: cgroupfs
...
</code></pre></div></div>

<p>It provides quite a lot of information about Docker configurations as well as work statistics.</p>

<h2 id="launch">Launch</h2>

<p>At this stage, the execution commands are given with no explanation. Later, more information on how they’re formed and what include will be given.</p>

<p>Let’s start with the easiest one:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run <span class="nt">-it</span> nginx bash
root@a6c26812d23b:/#
</code></pre></div></div>

<p>This command will begin downloading the <em>nginx</em> image on the initial call, so you will have to wait a few moments. After the image is downloaded, <em>bash</em> will run, and you will find yourself <strong>in a container</strong>.</p>

<p>Go through the file system, and look at the <em>/etc/nginx</em>. As you can see, its content does not match what you have on your system. This file system was generated by the <em>nginx</em> image. Everything you do within it will not affect your main file system. With the <code class="language-plaintext highlighter-rouge">exit</code>command, you can get back to your native system.</p>

<p>Now, let’s call the <code class="language-plaintext highlighter-rouge">cat</code> command, which is already in another container but is also launched from the <em>nginx</em> image:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run nginx <span class="nb">cat</span> /etc/nginx/nginx.conf

user  nginx<span class="p">;</span>
worker_processes  1<span class="p">;</span>

error_log  /var/log/nginx/error.log warn<span class="p">;</span>
pid        /var/run/nginx.pid<span class="p">;</span>
...
<span class="err">$</span>
</code></pre></div></div>

<p>The command is executed almost instantly since the image has already been uploaded. Unlike before, when a bash script and an interactive session were launched in the container, the <code class="language-plaintext highlighter-rouge">cat /etc/nginx/nginx.conf</code> command for the <em>nginx</em> image will display the contents of the specified file (taken from the running container’s file system) and return control to where you were before. You won’t end up inside the container.</p>

<p>The last launch option will be:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Note that no command is specified after the image name</span>
<span class="c"># This approach works if the launch command is written in the image</span>
<span class="nv">$ </span>docker run <span class="nt">-p</span> 8080:80 nginx
</code></pre></div></div>

<p>This command does not restore control, because Nginx starts running. Enter <code class="language-plaintext highlighter-rouge">localhost:8080</code>into your browser. You’ll see that the <em>Welcome to nginx!</em> page has loaded!. If you return to the terminal where the container was launched, you’ll see a log of requests to <code class="language-plaintext highlighter-rouge">localhost:8080</code>. You may stop nginx by pressing <kbd>Ctrl + C</kbd>.</p>

<p>Although each launch was different and resulted in various outcomes, the overall pattern of their work is consistent. Docker downloads the image automatically (the first argument after <code class="language-plaintext highlighter-rouge">docker run</code>) and, if necessary, runs the container with the specified command.</p>

<p><strong>An image is an independent file system</strong>. For now, we use ready-made images, but we will eventually learn how to create them ourselves.</p>

<p><strong>A container is a running process of the operating system in an isolated environment</strong> with an image file system.</p>

<p>A container is, once again, just a usual operating system process. The main difference is that Docker starts the process in an isolated environment due to the kernel’s capabilities (details in the end). The container sees its own process list, network, file system, and so forth. Unless otherwise specified, it cannot interact with your main operating system or anything stored or launched there.</p>

<p>Try running the <code class="language-plaintext highlighter-rouge">docker run -it ubuntu bash</code> command and typing <code class="language-plaintext highlighter-rouge">ps auxf</code> inside the running container. The output will be as follows:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.1  0.1  18240  3300 pts/0    Ss   15:39   0:00 /bin/bash
root        12  0.0  0.1  34424  2808 pts/0    R+   15:40   0:00 ps aux
</code></pre></div></div>

<p>There are only two processes, and the process ID of Bash is 1. To ensure that the <em>/home</em> directory is empty, you may use the <code class="language-plaintext highlighter-rouge">ls /home</code> command. Also, check out that the <code class="language-plaintext highlighter-rouge">root</code> user is the default one inside the container.</p>

<h2 id="whats-all-this-for">What’s all this for?</h2>

<p><strong>Docker is a general-purpose tool for delivering applications to machines (local computers or remote servers) and running them in an isolated environment.</strong></p>

<p>Remember the process when you had to build programs from the source. It’s likely to consist of the following steps:</p>

<ul>
  <li>Install all of the operating system dependencies (finding them is quite a task)</li>
  <li>Download the archive, unpack it</li>
  <li>Start configuration <code class="language-plaintext highlighter-rouge">make configure</code>
</li>
  <li>Start compilation <code class="language-plaintext highlighter-rouge">make compile</code>
</li>
  <li>Install <code class="language-plaintext highlighter-rouge">make install</code>
</li>
</ul>

<p>As you can see, the process is not always straightforward or quick, and in certain cases, it may even be impossible because of cryptic issues (not to mention the corruption of the operating system).</p>

<p>Docker simplifies this method by allowing you to run a single command with a near-perfect success rate. Look at a fictional example in which the Tunnel program is installed on a local computer in the <em>/usr/local/bin</em> directory. It uses the <em>tunnel</em> image:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>docker run <span class="nt">-v</span> /usr/local/bin:/out tunnel
</code></pre></div></div>

<p>This command moves the program’s executable file from the <em>tunnel</em> image in the <em>/usr/local/bin</em> directory on the main system. The <code class="language-plaintext highlighter-rouge">docker run</code> command launches a container from the <em>tunnel</em> image. The program is compiled locally and eventually ends up in the <em>/usr/local/bin</em> directory of the main file system. You may now run the program by typing <code class="language-plaintext highlighter-rouge">tunnel</code> in the terminal.</p>

<p>What if the program we are installing has dependencies? The secret is that the container was launched from a fully equipped image. It includes all necessary dependencies and ensures approximately 100% operability regardless of the status of the main OS.</p>

<p>It is not always necessary to copy a program from a container to your main system. It is enough to launch the container only when you need it. Assume we decided to create a static website using Jekyll. Jekyll is a popular static website generator written in Ruby, and even this guide is generated using it and Docker as well.</p>

<p>Earlier you have had to install at least Ruby and Jekyll itself as a gem on your main system (gem is the name of packages in Ruby). Furthermore, as with all such things, Jekyll only works with particular versions of Ruby, which leads to its own configuration issues.</p>

<p>Running Jekyll with Docker is reduced to just a single command executed in the blog directory (you can examine our guides <a href="https://github.com/hexletguides/hexletguides.github.io">repository</a>):</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>docker run <span class="nt">--rm</span> <span class="nt">--volume</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PWD</span><span class="s2">:/srv/jekyll"</span> <span class="nt">-it</span> jekyll/jekyll jekyll server
</code></pre></div></div>

<p>In the same way, a huge number of different software products are being launched at the moment. The further away, the more this approach takes over the world. Now, we dip into the origin of the name Docker.</p>

<p><amp-img src="/assets/images/docker/docker_logo.png" alt="docker logo" width="500" height="370" layout="responsive"><noscript><img src="/assets/images/docker/docker_logo.png" alt="docker logo" width="500" height="370"></noscript></amp-img></p>

<p>As you know, ships are the leading way to distribute goods around the world. Previously, the cost of transportation was high, because each cargo had its own shape and type of material.</p>

<p><amp-img src="/assets/images/docker/cargo.jpg" alt="loading cargo onto a ship" width="1200" height="747" layout="responsive"><noscript><img src="/assets/images/docker/cargo.jpg" alt="loading cargo onto a ship" width="1200" height="747"></noscript></amp-img></p>

<p>Loading a bag of fish or a car onto a ship are different tasks requiring different processes and tools. There were problems with loading methods that required a variety of cranes and tools. And, given the ship’s fragility, securely loading cargo on board was a challenging procedure.</p>

<p>But at some point, everything changed. The following picture says more than a thousand words:</p>

<p><amp-img src="/assets/images/docker/container_terminal.jpg" alt="shipping container terminal" width="1915" height="1277" layout="responsive"><noscript><img src="/assets/images/docker/container_terminal.jpg" alt="shipping container terminal" width="1915" height="1277"></noscript></amp-img></p>

<p>Containers have equalized all types of cargo and standardized loading and unloading tools around the world, which in turn led to a simplification of processes, acceleration, and, therefore, lower costs.</p>

<p>The same thing happened in software development. Docker has become a universal software delivery tool, regardless of its structure, dependencies, or installation method. All that is required for programs distributed via Docker is that they are contained within the image and do not interact with the main system or other containers. The importance of this fact cannot be overestimated. Now, updating software versions does not involve either the system itself or other programs. Nothing can break anymore. All you need to do is download a new image of the program you want to update. In other words, Docker removed the <a href="%5Bhttps://en.wikipedia.org/wiki/Dependency_hell%5D">dependency hell</a> problem and made the infrastructure <a href="https://martinfowler.com/bliki/ImmutableServer.html">immutable</a>.</p>

<p>Given the existence of numerous configuration tools (chef, puppet, ansible) prior to the Docker era, server management was somewhat daunting. The main cause of all problems was the mutable state. Programs are installed, updated, and deleted. This happens at different times and in somewhat different ways on different servers. Updating the version of a language like PHP, Ruby, or Python, for example, could be quite an adventure with a total loss of workability. It’s much easier to put a new server next to it and switch to it. In theory, Docker allows you to make such a switch. Because each running container exists in its own environment, it is best to forget about the old one and replace it with a new one. Moreover, the rollback in such a system is pretty superficial: all you need is to stop the new container and rebuild the old one using the previous image.</p>

<h2 id="application-in-a-container">Application in a container</h2>

<p>Let’s now discuss how an application corresponds to a container. There are two possible approaches:</p>

<ol>
  <li>The entire application is a container, inside which a process tree unfolds: an application, a web server, a database, and so on</li>
  <li>Every running container is an atomic service. In other words, each container, whether a web server or an application, is a single program</li>
</ol>

<p>In fact, only the second approach provides access to all of Docker’s advantages. Firstly, services are usually split over numerous servers and moved between them (for example, when a server crashes). Secondly, updating one service shouldn’t lead to stopping the others.</p>

<p>The first approach is extremely rare, yet sometimes required. Hexlet, for example, works in two modes. The website and its services follow the second model, in which each service is distinct, but for practical exercises performed in a browser, we follow the principle of “one user — one container.” Depending on the exercise, anything can be placed inside the container. At least, the Hexlet IDE itself always starts there, and it in turn generates terminals (processes). A database is launched in the same container in our database course, and a web server is launched in a web-related course. This method creates the illusion of working on a genuine machine and makes it simpler to maintain work with exercises. Just to be clear, you probably won’t require our use case, which is highly unique.</p>

<p>Another important aspect when working with containers relates to the state. For example, if the database is launched in a container, then its data should never be stored within the container. A container can be easily destroyed because it is an operating system process, and its existence is never permanent. Docker includes tools for storing and accessing data from the main file system. We’ll get to them later.</p>

<h2 id="working-with-images">Working with images</h2>

<p>Docker is more than just a program. This is an entire ecosystem with many projects and services. The main service you will have to work with is Registry, an image storage.</p>

<p>Generally, it works the same way as the package repository of any package manager. You can view its contents on the website <a href="https://hub.docker.com/">https://hub.docker.com/</a>, by clicking Explore.</p>

<p>When we run the <em>run</em> <code class="language-plaintext highlighter-rouge">docker run &lt;image name&gt;</code> command, Docker checks for the presence of the specified image on the local machine and downloads it if necessary. The list of images already downloaded to your computer can be displayed with the <code class="language-plaintext highlighter-rouge">docker images</code> command:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker images
REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE
workshopdevops_web                   latest              cfd7771b4b3a        2 days ago          817MB
hexletbasics_app                     latest              8e34a5f631ea        2 days ago          1.3GB
mokevnin/rails                       latest              96487c602a9b        2 days ago          743MB
ubuntu                               latest              2a4cca5ac898        3 days ago          111MB
Ruby                                 2.4                 713da53688a6        3 weeks ago         687MB
Ruby                                 2.5                 4c7885e3f2bb        3 weeks ago         881MB
nginx                                latest              3f8a4339aadd        3 weeks ago         108MB
elixir                               latest              93617745963c        4 weeks ago         889MB
postgres                             latest              ec61d13c8566        5 weeks ago         287MB
</code></pre></div></div>

<p>Let’s figure out how the image name is formed, and what it includes.</p>

<p>The second column in the output above is called TAG. The <code class="language-plaintext highlighter-rouge">docker run nginx</code> command is, in fact, a shortcut for the <code class="language-plaintext highlighter-rouge">docker run nginx:latest</code> which was executed. That is, we do not just download the <em>nginx</em> image, but its particular version. The latest is the default tag. It’s easy to guess that it means the latest version of the image.</p>

<p>It is essential to understand that this is just an agreement, not a rule. A specific image may or may not have the <em>latest</em> tag, but it will not contain the most recent changes just because no one publishes them. ВPopular images, on the other hand, follow the agreement. As it is clear from the context, tags in Docker are changeable; that is, no one guarantees that downloading an image with the same tag on different computers at different times will result in the same thing. This approach may seem strange and unreliable because there are no guarantees, but in practice, there are certain agreements that all popular images follow. The latest tag always contains the most recent version and is constantly updated, but <a href="https://semver.org/">semantic versioning</a> is also actively used. Let’s have a look at https://hub.docker.com/_/nginx</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>1.13.8, mainline, 1, 1.13, latest
1.13.8-perl, mainline-perl, 1-perl, 1.13-perl, perl
1.13.8-alpine, mainline-alpine, 1-alpine, 1.13-alpine, alpine
1.13.8-alpine-perl, mainline-alpine-perl, 1-alpine-perl, 1.13-alpine-perl, alpine-perl
1.12.2, stable, 1.12
1.12.2-perl, stable-perl, 1.12-perl
1.12.2-alpine, stable-alpine, 1.12-alpine
1.12.2-alpine-perl, stable-alpine-perl, 1.12-alpine-perl
</code></pre></div></div>

<p>Tags with the complete semantic version (x.x.x) are always immutable, even if they contain something else, such as <em>1.12.2-alphine</em>. This version is safe to use in the production environment. When the path version changes, tags such as <em>1.12</em> are updated. That is, there may be version <em>1.12.2</em> inside the image, followed by <em>1.12.8</em> in the future. The same applies to versions that merely specify the major version, for example, <em>1</em>. Only in this case, the update is not only on the patch but also on the minor version.</p>

<p>As you may recall, the <code class="language-plaintext highlighter-rouge">docker run</code> command downloads the image if it is not available locally, but this check has nothing to do with updating the content. In short, if the <em>nginx:latest</em> has been updated, <code class="language-plaintext highlighter-rouge">docker run</code> will not download it; instead, it will use the <em>latest</em>, that is already downloaded. Another command for guaranteed image updates is <code class="language-plaintext highlighter-rouge">docker pull</code>. It always checks whether the image has been updated for a certain tag.</p>

<p>Along with tags, the image name can include a prefix, such as <code class="language-plaintext highlighter-rouge">etsy/chef</code>. This prefix is the service account name that is used to create images for the Registry. The majority of the images have a prefix, but there’s still a small set, literally a hundred images, with no prefix at all. These images are special since they are supported by Docker itself. Therefore, if there is no prefix in the image name, this is an official image. You can check their list: https://github.com/docker-library/official-images/tree/master/library</p>

<p>Images can be deleted with the <code class="language-plaintext highlighter-rouge">docker rmi &lt;imagename&gt;</code> command.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker rmi Ruby:2.4
Untagged: Ruby:2.4
Untagged: Ruby@sha256:d973c59b89f3c5c9bb330e3350ef8c529753ba9004dcd1bfbcaa4e9c0acb0c82
</code></pre></div></div>

<p>If Docker has at least one container from the removed image, then it will not allow to delete it for obvious reasons. If you still want to delete both the image and all containers associated with it, use the <code class="language-plaintext highlighter-rouge">-f</code> flag.</p>

<h2 id="container-management">Container management</h2>

<p><amp-img src="/assets/images/docker/docker-container-lifecycle.png" alt="Docker Container LifeCycle" width="1129" height="575" layout="responsive"><noscript><img src="/assets/images/docker/docker-container-lifecycle.png" alt="Docker Container LifeCycle" width="1129" height="575"></noscript></amp-img></p>

<p>The picture describes the life cycle (finite state machine) of the container. The circles depict the states, the console commands are highlighted in bold, and the squares show what is actually being executed.</p>

<p>Follow the path of the  <code class="language-plaintext highlighter-rouge">docker run</code>command. This single command performs two actions in Docker: creating a container and starting it. There are more complex execution scenarios, but in this section, we will consider only the basics.</p>

<p>Let’s run nginx so that it works in the background. To do this, we will add the <code class="language-plaintext highlighter-rouge">-d</code> flag after the word <em>run</em>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 8080:80 nginx
431a3b3fc24bf8440efe2bca5bbb837944d5ae5c3b23b9b33a5575cb3566444e
</code></pre></div></div>

<p>After executing the command, Docker return control and outputs the container ID. Make sure that nginx is working by opening <code class="language-plaintext highlighter-rouge">localhost:8080</code> in browser. Unlike the previous launch, our nginx works in the background, which means its output (logs) is not visible. You can view it using the <code class="language-plaintext highlighter-rouge">docker logs</code> command, which requires the container ID:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker logs 431a3b3fc24bf8440efe2bca5bbb837944d5ae5c3b23b9b33a5575cb3566444e

172.17.0.1 - - <span class="o">[</span>19/Jan/2018:07:38:55 +0000] <span class="s2">"GET / HTTP/1.1"</span> 200 612 <span class="s2">"-"</span> <span class="s2">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"</span> <span class="s2">"-"</span>
</code></pre></div></div>

<p>You can also open a log pager using <code class="language-plaintext highlighter-rouge">tail -f</code>. To do this, run <code class="language-plaintext highlighter-rouge">docker logs -f 431a3b3fc24bf8440efe2bca5bbb837944d5ae5c3b23b9b33a5575cb3566444e</code>. The log will now be updated every time you refresh the page in the browser. You can exit this mode by pressing <kbd>Ctrl + C</kbd>, but the container will not stop.</p>

<p>Now we will output information about the running containers with the <code class="language-plaintext highlighter-rouge">docker ps</code> command:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>CONTAINER ID        IMAGE                            COMMAND                  CREATED             STATUS              PORTS                                          NAMES
431a3b3fc24b        nginx                            <span class="s2">"nginx -g 'daemon of…"</span>   2 minutes ago       Up 2 minutes        80/tcp                                         wizardly_rosalind
</code></pre></div></div>

<p>Columns description:</p>

<ul>
  <li>CONTAINER_ID — container identifier. Just like Git, Docker uses an abbreviated hash entry</li>
  <li>IMAGE — the name of the image that is used to create this container. If no tag is specified, then the latest is implied <em>latest</em> is implied</li>
  <li>COMMAND — a command that was executed at the start of the container</li>
  <li>CREATED — container creation time</li>
  <li>STATUS — current state</li>
  <li>PORTS — port forwarding</li>
  <li>NAMES — unique names. In addition to the identifier, Docker allows you to specify a name. It’s much easier to handle the container this way. If the name is not provided when creating the container, Docker will generate a random one. Like the one, Nginx has in the output above</li>
</ul>

<p>(<em>The <code class="language-plaintext highlighter-rouge">docker stats</code> command gives information about running containers’ resource consumption).</em></p>

<p>Let’s try to stop the container now. Run the following command:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Instead of CONTAINER_ID, you can specify a name</span>
<span class="nv">$ </span>docker <span class="nb">kill </span>431a3b3fc24b <span class="c"># docker kill wizardly_rosalind</span>
431a3b3fc24b
</code></pre></div></div>

<p>If you type <code class="language-plaintext highlighter-rouge">docker ps</code>, you won’t see this container, it has been deleted.</p>

<p>The <code class="language-plaintext highlighter-rouge">docker ps</code> command outputs only running containers. However, there may be some stopped ones as well. Moreover, they can stop both upon successful completion and in case of errors. Try typing <code class="language-plaintext highlighter-rouge">docker run ubuntu ls</code>, followed by <code class="language-plaintext highlighter-rouge">docker run ubuntu bash -c "unknown"</code>. These commands do not initiate a long-running process. Instead, the first one terminates immediately after execution, and the second with an error, because such a command does not exist.</p>

<p>The <code class="language-plaintext highlighter-rouge">docker ps -a</code> command will now output all containers. The first three lines of output will be:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>CONTAINER ID        IMAGE                            COMMAND                  CREATED                  STATUS                       PORTS                                          NAMES
85fb81250406        ubuntu                           <span class="s2">"bash -c unkown"</span>         Less than a second ago   Exited <span class="o">(</span>127<span class="o">)</span> 3 seconds ago                                                  loving_bose
c379040bce42        ubuntu                           <span class="s2">"ls"</span>                     Less than a second ago   Exited <span class="o">(</span>0<span class="o">)</span> 9 seconds ago                                                    determined_tereshkova
</code></pre></div></div>

<p>Here are our two most recent launches. If you look at the STATUS column, you can see that both containers are in the Exited state. That is, the running command inside them was executed, and they stopped. The only difference is that one completed successfully (0), and the other did not (127). Even after it has been stopped, the container can be restarted:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>docker start determined_tereshkova <span class="c"># In your case, there will be another name</span>

</code></pre></div></div>

<p>Only this time you won’t see the output. Use the <code class="language-plaintext highlighter-rouge">docker logs determined_tereshkova</code> command to see it.</p>

<h2 id="interactionbetween-thecomponentsof-asystem">Interaction between the components of a system</h2>

<p>Running an isolated container that exists entirely within itself is useless. In general, the container must interact with the outside world, accept incoming requests to a specific port, execute requests to other services, read shared files, and write to them. When you create a container, you can configure all of these features.</p>

<h3 id="interactive-mode">Interactive mode</h3>

<p>As shown, the simplest way to use Docker is to create a container and execute some commands inside it:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run ubuntu <span class="nb">ls</span> /usr
bin
games
include
lib
<span class="nb">local
</span>sbin
share
src
<span class="err">$</span>
</code></pre></div></div>

<p>Docker returns control after executing the command, and we are no longer inside the container. If we try to run bash in the same way, we will not get what we expected:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run ubuntu bash
<span class="err">$</span>
</code></pre></div></div>

<p>The thing is that <code class="language-plaintext highlighter-rouge">bash</code> starts an interactive session within the container. To interact with it, keep the STDIN stream open and the TTY running (pseudo-terminal). Therefore, to start interactive sessions, make sure to include the <code class="language-plaintext highlighter-rouge">-i</code> and <code class="language-plaintext highlighter-rouge">-t</code> options. They are typically added together as <code class="language-plaintext highlighter-rouge">-it</code>. So, the correct way to start bash is <code class="language-plaintext highlighter-rouge">docker run -it ubuntu bash</code>.</p>

<h3 id="ports">Ports</h3>

<p>If you run Nginx usint the <code class="language-plaintext highlighter-rouge">docker run nginx</code>command, it will be unable to accept any request, even though it listens to port <em>80</em> inside the container (let me remind you that each container exists in its own network by default). But if you run it like this: <code class="language-plaintext highlighter-rouge">docker run -p 8080:80 nginx</code>, then nginx will start responding on port <em>8080</em>.</p>

<p>The <code class="language-plaintext highlighter-rouge">-p</code> flag specifies how and which ports should be exposed to the outside. The format <code class="language-plaintext highlighter-rouge">8080:80</code> stands for “expose port <em>8080</em> inside the container to port <em>80</em> outside the container”. Furthermore, port <em>8080</em> s by default listened to on <code class="language-plaintext highlighter-rouge">0.0.0.0</code>, that is, on all available interfaces. As a result, the container launched this way is accessible not only via <code class="language-plaintext highlighter-rouge">localhost:8080</code> but also from outside the machine (if access is not denied somehow else). If you only need to do a <em>loopback</em>, the command is <code class="language-plaintext highlighter-rouge">docker run -p 127.0.0.1:8080:80 nginx</code>.</p>

<p>Docker allows you to forward an unlimited number of ports. In the case of Nginx, for example, it is frequently necessary to use both ports <code class="language-plaintext highlighter-rouge">80</code> and <code class="language-plaintext highlighter-rouge">443</code> for HTTPS. You can do it this way: <code class="language-plaintext highlighter-rouge">docker run -p 80:80 -p 443:443 nginx</code>. You can read about the other ways to forward ports in the official documentation.</p>

<h3 id="volumes">Volumes</h3>

<p>Accessing the main file system is another common task. When launching nginx container, for example, you may provide the configuration that is stored on the main fs (file system). Docker will forward it in the internal fs for Nginx to read and use.</p>

<p>The <code class="language-plaintext highlighter-rouge">-v</code>option is used for forwarding. Here’s how to start a bash session from an Ubuntu image by connecting the command history from the main file system: <code class="language-plaintext highlighter-rouge">docker run -it -v ~/.bash_history:/root/.bash_history ubuntu bash</code>. The history will be displayed if you press the up arrow in the open bash-shell. You can forward both files and directories. Any changes made inside the volume have an effect both inside and outside the container, and all operations are available by default. The number of files and directories that can be forwarded is unlimited, just like the number of ports.</p>

<p>There are some key rules to remember when working with Volumes:</p>

<ul>
  <li>The path to the file in the external system must be absolute</li>
  <li>If the inner path (what follows <code class="language-plaintext highlighter-rouge">:</code>) does not exist, Docker will create all the necessary directories and files. If it does, Docker will replace the old one with the one that was forwarded</li>
</ul>

<p>Docker provides various other options for building and using Volumes, in addition to forwarding a part of the fs outside. Read the official documentation for further details.</p>

<h3 id="environment-variables">Environment variables</h3>

<p>The application in a container is often configured via environment variables following <a href="https://12factor.net">12factors</a>. There are two ways of installing them:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">-e</code>flag is used as follows: <code class="language-plaintext highlighter-rouge">docker run -it -e "HOME=/tmp" ubuntu bash</code>
</li>
  <li>The <code class="language-plaintext highlighter-rouge">--env-file</code> option inserts a special file containing environment variable definitions into the container</li>
</ul>

<h2 id="preparing-your-own-docker-image">Preparing your own docker image</h2>

<p>Creating and publishing your own image is as simple as using it. The whole process is divided into three steps:</p>

<ul>
  <li>Create <code class="language-plaintext highlighter-rouge">Dockerfile</code> in the project’s root. The process of creating an image should be described inside</li>
  <li>Build the image using the <code class="language-plaintext highlighter-rouge">docker build</code> command</li>
  <li>Publish the image to Registry with the <code class="language-plaintext highlighter-rouge">docker push</code> command</li>
</ul>

<p>Let’s consider the image creation process by the example of packaging the <code class="language-plaintext highlighter-rouge">eslint</code> linter (do not forget to repeat it by yourself). As a result, we will have an image that can be used as follows:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">-v</span> /path/to/js/files:/app my_account_name/eslint

/app/index.js
  3:6  error  Parsing error: Unexpected token

  1 | import path from <span class="s1">'path'</span><span class="p">;</span>
  2 |
<span class="o">&gt;</span> 3 | path<span class="o">(</span><span class="p">;</span><span class="o">)</span>
    |      ^
  4 |

✖ 1 problem <span class="o">(</span>1 error, 0 warnings<span class="o">)</span>
</code></pre></div></div>

<p>So, simply run the container from this image by attaching the directory with the js files to the internal directory <em>/app</em> as Volume.</p>

<h3 id="1-the-following-is-the-final-directory-structure-with-the-files-from-which-the-image-will-be-constructed">1. The following is the final directory structure with the files from which the image will be constructed:</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>eslint-docker/
    Dockerfile
    eslintrc.yml
</code></pre></div></div>

<p>The <em>eslintrc.yml</em> file contains the linter configuration. It is read automatically if it’s in the home directory and named <em>.eslintrc.yml</em>. That is, this file should be placed in the image’s <em>/root</em> directory under this name.</p>

<h3 id="2-dockerfile">2. Dockerfile</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code># Dockerfile
FROM node:9.3

WORKDIR /usr/src

RUN npm install -g eslint babel-eslint
RUN npm install -g eslint-config-airbnb-base eslint-plugin-import

COPY eslintrc.yml /root/.eslintrc.yml

CMD ["eslint", "/app"]
</code></pre></div></div>

<p>Dockerfile has quite a simple format. An instruction (directive) and its description are stated on each line.</p>

<h4 id="from">FROM</h4>

<p>The Dockerfile FROM instruction is required to set the base image to inherit from. It is important to note here that the images are based on each other and together form a big tree.</p>

<p>The <em>busybox</em> image can be found at the root of this tree. Because Docker provides ready-to-use images for each ecosystem and stack, it is not directly used in applied tasks.</p>

<h4 id="run">RUN</h4>

<p>The main Dockerfile instruction. In fact, we will state the <em>sh</em> command that will be run within the environment here. When creating an image, it is typically specified in the FROM instruction. Since by default everything is executed from the <em>root</em> user, there is no need to <em>sudo</em> (and most likely it is not in the base image). Also, keep in mind that building an image is not an interactive process. When using a command that potentially requires something from the user, it is necessary to hide its output. In the case of package managers, for example, they do the following: <code class="language-plaintext highlighter-rouge">apt-get install -y curl</code>. The <code class="language-plaintext highlighter-rouge">-y</code> flag indicates that installation should proceed without additional questions.</p>

<p>A Docker image is technically a set of so-called layers rather than a single file. Each RUN call creates a new layer, which can be viewed as a collection of files generated and updated (including deletion) by the RUN command. By caching unchanged layers, you can significantly improve system performance. On the other hand, Docker reuses layers in different images if they are identical, reducing both download speed and disk space occupied. The subject of layers cache is quite important when extensively using Docker. To get the most of it, you must first grasp how it works and how to precisely define the <code class="language-plaintext highlighter-rouge">RUN</code> instructions.</p>

<h4 id="copy">COPY</h4>

<p>The COPY instruction, as the name implies, copies a file or directory from the main fs to the image. But the transferred files should be in the same directory as the Dockerfile. We generally use this instruction to pack an application in an image.</p>

<h4 id="workdir">WORKDIR</h4>

<p>Sets the working directory. All subsequent instructions will be assumed to be executed from it. By default, the <code class="language-plaintext highlighter-rouge">WORKDIR</code> instruction acts like a <code class="language-plaintext highlighter-rouge">cd</code>command. Besides, when we launch the container, it also starts from the working directory. For example, by running bash, you will end up inside it.</p>

<h4 id="cmd">CMD</h4>

<p>The same instruction that defines the <code class="language-plaintext highlighter-rouge">docker run</code> default action. It is only used if the container was launched without a command; otherwise, it is ignored.</p>

<h3 id="3-building">3. Building</h3>

<p>To create a docker image, use the <code class="language-plaintext highlighter-rouge">docker build</code> command. Use <code class="language-plaintext highlighter-rouge">-t</code> flag to provide the image name, including the account name and tag. As usual, if you do not specify the tag, then the <em>latest</em> will be set.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> my_account_name/eslint <span class="nb">.</span>
</code></pre></div></div>

<p>After running this command, the current image will be listed in the <code class="language-plaintext highlighter-rouge">docker images</code>. You can even start using it, there is no need to publish it to Registry. Let me remind you that the <code class="language-plaintext highlighter-rouge">docker run</code> command does not search for an updated version of the image if an image with the same name and tag already exist locally.</p>

<h3 id="4-publishing">4. Publishing</h3>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker push my_account_name/eslint
</code></pre></div></div>

<p>To complete the publishing, you must meet two conditions:</p>

<ul>
  <li>Register on Docker Cloud and create a repository for the image there</li>
  <li>Log in to the CLI interface using the <code class="language-plaintext highlighter-rouge">docker login</code> command.</li>
</ul>

<h2 id="docker-compose">Docker Compose</h2>

<p>Docker Compose is a tool that allows you to develop a project locally using Docker. It is similar to Vagrant in its purpose.</p>

<p>Docker Compose also helps to manage a set of containers, each of which is a separate project service. Management includes building, dependency-aware launch, and configuration. Docker Compose configuration is specified in the <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file at the project roo. It looks as follows:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1"># https://github.com/hexlet-basics/hexlet_basics</span>

<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.3'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres</span>
  <span class="na">app</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">services/app</span>
      <span class="na">dockerfile</span><span class="pi">:</span> <span class="s">Dockerfile</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">mix phx.server</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">${PORT}:${PORT}"</span>
    <span class="na">env_file</span><span class="pi">:</span> <span class="s1">'</span><span class="s">.env'</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">./services/app:/app:cached"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">~/.bash_history:/root/.bash_history:cached"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">.bashrc:/root/.bashrc:cached"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">/var/tmp:/var/tmp:cached"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">/tmp:/tmp:cached"</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
</code></pre></div></div>

<h2 id="in-action">In action</h2>

<p>Setting up project machines with Docker usually comes down to installing Docker. Then you just have to deploy. The basic process is:</p>

<ol>
  <li>Download a new image</li>
  <li>Stop the old container</li>
  <li>Build a new one</li>
</ol>

<p>This process does not depend on the technology stack. You can deploy (as well as configure machines) using <a href="https://docs.ansible.com/ansible/2.5/modules/docker_container_module.html">Ansible</a>.</p>

<p>Another option, suitable for more complex projects, is to use special orchestration tools such as <a href="https://kubernetes.io/">Kubernetes</a>. It generally requires extensive preparation, including an understanding of how distributed systems operate.</p>

<h2 id="docker-whats-under-the-hood">Docker: what’s under the hood?</h2>

<p>Docker’s isolation is provided by the <a href="https://en.wikipedia.org/wiki/Cgroups">Cgroups</a> and <a href="https://en.wikipedia.org/wiki/Linux_namespaces">Namespaces</a> kernel features. They enable you to run an operating system process not just in an isolated environment, but also with limited use of hardware resources (RAM or CPU).</p>

      
      
    </div>
  </body>
</html>
