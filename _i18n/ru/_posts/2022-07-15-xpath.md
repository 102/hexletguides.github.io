---
title: Введение в XPath
description: Как устроен язык запросов XPath. Разбираемся в поиске информации внутри XML
author: Никита Михайлов
hidden: true
---

Язык разметки XML с самого первого стандарта окружает пользователей компьютеров: таблицы в Excel, выгрузки из интернет-магазинов, RSS для получения коротких новостей и так далее основаны на XML. Хоть визуальное отображение отличается на устройствах и в программах, но в основе лежит единый формат.

При таком количестве информации, которая может находиться в XML встаёт вопрос о перемещении и выборке внутри документа. Как это сделать быстро? Какие средства применять, чтобы из тысячи товаров интернет магазина найти только те, которые отвечают нашим требованиям? Для решения задач навигации и поиска внутри XML используется язык запросов XPath.

В этой статье разберём:

* для кого может быть полезен _XPath_
* базовые конструкции языка для поиска информации в XML
* чем XPath отличается от CSS-селекторов при поиске в HTML

## Синтаксис XPath

Перед тем, как приступить к написанию запросов, стоит создать базовый пример XML, по которому и будет производиться поиск. Таким XML будет некоторый список курсов по вёрстке на Хекслете:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<courses>
  <title>Курсы HTML и CSS (вёрстка)</title>
  <description>На курсах по вёрстке вы познакомитесь с основами HTML и CSS, научитесь верстать адаптивные страницы, работать с препроцессорами. Освоите современные технологии и инструменты, включая Flex, Sass, Bootstrap.</description>
  <course>
    <name>Основы современной вёрстки</name>
    <tags>HTML5, CSS, DevTools, вёрстка</tags>
    <duration value="9">9 часов</duration>
    <url lang="ru">https://ru.hexlet.io/courses/layout-designer-basics</url>
    <url lang="en">https://hexlet.io/courses/layout-designer-basics</url>
  </course>
  <course>
    <name>Основы вёрстки контента</name>
    <tags>CSS3, HTML5, Селекторы, Доступность, CSS Columns, CSS Units, Вёрстка</tags>
    <duration value="18">18 часов</duration>
    <url lang="ru">https://ru.hexlet.io/courses/css-content</url>
    <url lang="en">https://hexlet.io/courses/css-content</url>
  </course>
  <course>
    <name>Bootstrap 5: Основы верстки</name>
    <tags>Bootstrap 5, Адаптивность, HTML, CSS3</tags>
    <duration value="10">10 часов</duration>
    <url lang="ru">https://ru.hexlet.io/courses/bootstrap_basic</url>
    <url lang="en">https://hexlet.io/courses/bootstrap_basic</url>
  </course>
</courses>
```

Это учебный пример. Для отработки навыков XPath подойдёт любой XML, а структура может сильно отличаться. Принципы XPath сохраняться, так как стандарт XML позволяет использовать элементы с произвольными тегами.

Для тестирования результата подойдут онлайн-сервисы, такие, как:

* [Code Beautify](https://codebeautify.org/Xpath-Tester)
* [XPather](http://xpather.com/)

### Абсолютные пути

Самый простой запрос состоит из обращения к корневому элементу. Для этого достаточно выполнить запрос `/courses`. Нам вернётся XML в том виде, как он представлен в примере выше, кроме строки `<?xml version="1.0" encoding="UTF-8"?>`, так как элемент не внутри `<courses>`:

```xml
<courses>
  <title>Курсы HTML и CSS (вёрстка)</title>
  <description>На курсах по вёрстке вы познакомитесь с основами HTML и CSS, научитесь верстать адаптивные страницы, работать с препроцессорами. Освоите современные технологии и инструменты, включая Flex, Sass, Bootstrap.</description>
  <course>
    <name>Основы современной вёрстки</name>
    <tags>HTML5, CSS, DevTools, вёрстка</tags>
    <duration value="9">9 часов</duration>
    <url lang="ru">https://ru.hexlet.io/courses/layout-designer-basics</url>
    <url lang="en">https://hexlet.io/courses/layout-designer-basics</url>
  </course>
  <course>
    <name>Основы вёрстки контента</name>
    <tags>CSS3, HTML5, Селекторы, Доступность, CSS Columns, CSS Units, Вёрстка</tags>
    <duration value="18">18 часов</duration>
    <url lang="ru">https://ru.hexlet.io/courses/css-content</url>
    <url lang="en">https://hexlet.io/courses/css-content</url>
  </course>
  <course>
    <name>Bootstrap 5: Основы верстки</name>
    <tags>Bootstrap 5, Адаптивность, HTML, CSS3</tags>
    <duration value="10">10 часов</duration>
    <url lang="ru">https://ru.hexlet.io/courses/bootstrap_basic</url>
    <url lang="en">https://hexlet.io/courses/bootstrap_basic</url>
  </course>
</courses>
```

В качестве результата XPath возвращает узлы XML-документа.

Продолжим цепочку и обратимся к описанию из элемента `<description>`. Для этого добавим в запрос путь к `description`: `/courses/description`. Результатом выполнения станет:

```xml
<description>На курсах по вёрстке вы познакомитесь с основами HTML и CSS, научитесь верстать адаптивные страницы, работать с препроцессорами. Освоите современные технологии и инструменты, включая Flex, Sass, Bootstrap.</description>
```

Путь, который строится от корневого элемента, называется _абсолютным_. Используя схему из прошлого запроса можно обратиться к любому элементу внутри XML.

А что если обратиться к имени курса? Какое именно поле `<name>` будет возвращено? Ответ: в этом случае вернутся `<name>` из всех курсов.

Запрос `/courses/course/name` вернёт:

```xml
<name>Основы современной вёрстки</name>
<name>Основы вёрстки контента</name>
<name>Bootstrap 5: Основы верстки</name>
```

Вот список некоторых базовых запросов и их результат:

| Запрос          | Результат                                                                                |
|-----------------|------------------------------------------------------------------------------------------|
| `/courses/course` | Все данные из всех элементов `<course></course>`                                         |
| `/courses/course/name` | `<name>Основы современной вёрстки</name>`<br/>`<name>Основы вёрстки контента</name>`<br/>`<name>Bootstrap 5: Основы верстки</name>` |
| `/courses/course/duration` | `<duration value="9">9 часов</duration>`<br/>`<duration value="18">18 часов</duration>`<br/>`<duration value="10">10 часов</duration>` |

### Относительные пути

Прошлые запросы строились с помощью _абсолютных путей_, то есть нужно было чётко указать полный путь до информации. Бывают ситуации, когда полный путь неизвестен в силу некоторых причин или необходимо получить уникальное поле и мы точно об этом знаем. В этом случае возможно использовать _относительный путь_, который произведёт поиск по всему XML и вернёт узлы, подходящие под запрос.

Для составления относительного пути используется конструкция `//` после которой можно написать любое поле и получить результат. Например, `//name` вернёт поля `<name>` из XML:

```xml
<name>Основы современной вёрстки</name>
<name>Основы вёрстки контента</name>
<name>Bootstrap 5: Основы верстки</name>
```

Проблема такого подхода — уникальность полей. В документах одни и те же имена полей могут обозначать разные данные в зависимости от расположения, поэтому используйте относительные пути там, где уверены в возвращаемых данных. Например, в нашем примере название курса может быть заключено в `<title>`:

```xml
<courses>
  <title>Курсы HTML и CSS (вёрстка)</title>
  <!-- ... -->
    
  <course>
    <title>Основы современной вёрстки</title>
    <!-- ... -->
  </course>
    
  <course>
    <title>Основы вёрстки контента</title>
    <!-- ... -->
  </course>
    
  <course>
    <title>Bootstrap 5: Основы верстки</title>
    <!-- ... -->
  </course>
    
</courses>
```

Запрос `//title` вернёт не только имена курсов, но и узел, который находится в `<courses>`:

```xml
<title>Курсы HTML и CSS (вёрстка)</title>
<title>Основы современной вёрстки</title>
<title>Основы вёрстки контента</title>
<title>Bootstrap 5: Основы верстки</title>
```

Через относительные пути разработчики, иногда, экономят пару секунд на опускание корневого элемента. То есть, вместо `/courses/course/name` пишут `//course/name`. Попробуйте прошлые примеры перевести на относительные пути с помощью такого механизма

Несколько примеров запросов с идентичными ответами, как и в прошлой таблице:

| Запрос              | Результат                                                    |
| ------------------- | ------------------------------------------------------------ |
| `//course`          | Все данные из всех элементов `<course></course>`             |
| `//name`            | `<name>Основы современной вёрстки</name>`<br/>`<name>Основы вёрстки контента</name>`<br/>`<name>Bootstrap 5: Основы верстки</name>` |
| `//course/duration` | `<duration value="9">9 часов</duration>`<br/>`<duration value="18">18 часов</duration>`<br/>`<duration value="10">10 часов</duration>` |

### Предикаты

В примерах запросов к именам возвращались имена всех курсов которые были найдены, что, в некоторых ситуациях, может быть избыточно. Что делать, если хочется получить данные только по первому курсу в `<courses>`? На помощь приходят предикаты — конструкции, с помощью которых можно отфильтровать элементы по заданным условиям. 

Выберем ключевые слова первого курса по вёрстке. Для этого достаточно использовать запрос `//course[1]/tags`:

```xml
<tags>HTML5, CSS, DevTools, вёрстка</tags>
```

`[1]` — это предикат с условием: «Взять элемент по индексу 1». Попробуйте сделать запрос ко второму или третьему элементу. Достаточно поменять только одну цифру! 

---

Интересно, что в отличие от принятых стандартов программирования, в _XPath_ индексы элементов начинаются с единицы, а не с нуля. Если вы уже программируете, то это может немного запутать

---

Предикаты помогают делать точные выборки. Например, получить ссылки на русскоязычные страницы курсов. Для этого нужно получить элементы `<url>` у которых атрибут `lang` равен `ru`. Делается это указанием атрибута и значения, а чтобы _XPath_ отличил атрибут от элемента перед атрибутом указывается символ `@`. 

Теперь запрос будет выглядеть так: `//course/url[@lang="ru"]`

```xml
<url lang="ru">https://ru.hexlet.io/courses/layout-designer-basics</url>
<url lang="ru">https://ru.hexlet.io/courses/css-content</url>
<url lang="ru">https://ru.hexlet.io/courses/bootstrap_basic</url>
```

Бывает полезно выбрать элементы, которые имеют хоть какой-то атрибут. Для этого можно использовать конструкцию `//*[@*]`:

```xml
<duration value="9">9 часов</duration>
<url lang="ru">https://ru.hexlet.io/courses/layout-designer-basics</url>
<url lang="en">https://hexlet.io/courses/layout-designer-basics</url>
<duration value="18">18 часов</duration>
<url lang="ru">https://ru.hexlet.io/courses/css-content</url>
<url lang="en">https://hexlet.io/courses/css-content</url>
<duration value="10">10 часов</duration>
<url lang="ru">https://ru.hexlet.io/courses/bootstrap_basic</url>
<url lang="en">https://hexlet.io/courses/bootstrap_basic</url>
```

Как можно понять, знак `*` обозначает «все/любой».

Когда выбраны элементы по атрибутам, то можно произвести дополнительную фильтрацию по этим значениям. Например, найдём элементы `<duration>` со значением атрибута `value` больше `9`. Что нужно узнать из нового — внутри предикатов используются знакомые, по языкам программирования, операторы сравнения:

* `>` — больше
* `<` — меньше
* `>=` — больше или равно
* `<=` — меньше или равно
* `=` — равно
* `!=` — не равно

Запрос будет выглядеть так: `//course/duration[@value > 9]`:

```xml
<duration value="18">18 часов</duration>
<duration value="10">10 часов</duration>
```

Это, конечно, всё интересно, но мало кому нужно выбирать только одно поле. Скорее всего нам нужны данные по всему курсу или другому его полю. Как одновременно использовать предикат и обращаться к другим полям? В этом нет ничего сложного! Предикат необязательно должен идти в конце запроса, он может находиться в любой его части, а внутри него может быть не только выборка по атрибуту или индексу, а новые пути по которым нужно сделать проверку.

Звучит сложно, но на деле всё очень просто. Мы уже знаем как, с помощью предиката, отфильтровать данные по полю `<duration>`. Это делалось с помощью конструкции `duration[@value > 9]`. А если эта конструкция будет предикатом для `<course>`? Именно это и нужно сделать, чтобы получить данные о курсах, у которых длительность больше 9 часов: `//course[duration[@value > 9]]`

```xml
<course>
  <title>Основы вёрстки контента</title>
  <tags>CSS3, HTML5, Селекторы, Доступность, CSS Columns, CSS Units, Вёрстка</tags>
  <duration value="18">18 часов</duration>
  <url lang="ru">https://ru.hexlet.io/courses/css-content</url>
  <url lang="en">https://hexlet.io/courses/css-content</url>
</course>
<course>
  <title>Bootstrap 5: Основы верстки</title>
  <tags>Bootstrap 5, Адаптивность, HTML, CSS3</tags>
  <duration value="10">10 часов</duration>
  <url lang="ru">https://ru.hexlet.io/courses/bootstrap_basic</url>
  <url lang="en">https://hexlet.io/courses/bootstrap_basic</url>
</course>
```

Можно продолжить этот запрос и получить только имена курсов. В таком случае предикат будет уже в середине запроса, а не в его конце. `//course[duration[@value > 9]]/name`:

```xml
<name>Основы вёрстки контента</name>
<name>Bootstrap 5: Основы верстки</name>
```

### Функции

В прошлых примерах запросы затрагивали теги и атрибуты, но не сами данные, а ведь это огромный пласт информации по которой можно делать выборки. Для решения этой задачи используются встроенные в _XPath_ функции. Они являются частью предикатов, как, например `@`. Попробуем найти курс с названием «Основы вёрстки контента». 

Для поиска по тексту внутри элемента используется функция `text()`. Её задача — получить текстовое значение элемента и, при необходимости, сравнить с условием. Вот как будет выглядеть запрос для поиска курса с нужным именем: `//course[name[text()="Основы вёрстки контента"]]`

```xml
<course>
  <name>Основы вёрстки контента</name>
  <tags>CSS3, HTML5, Селекторы, Доступность, CSS Columns, CSS Units, Вёрстка</tags>
  <duration value="18">18 часов</duration>
  <url lang="ru">https://ru.hexlet.io/courses/css:content</url>
  <url lang="en">https://hexlet.io/courses/css:content</url>
</course>
```

Но что если нам известно только часть названия? Для этого существует функция `contains()` которая принимает два аргумента:

1. Строка, где будет производиться поиск
2. Подстрока, которая будет искаться

Например, найдём курс, у которого в ключевых словах есть слово «Bootstrap». Функция примет текстовое значение элемента `tags` и найдёт там слово «Bootstrap»: `//course[tags[contains(text(), "Bootstrap")]]`

```xml
<course>
  <name>Bootstrap 5: Основы верстки</name>
  <tags>Bootstrap 5, Адаптивность, HTML, CSS3</tags>
  <duration value="10">10 часов</duration>
  <url lang="ru">https://ru.hexlet.io/courses/bootstrap_basic</url>
  <url lang="en">https://hexlet.io/courses/bootstrap_basic</url>
</course>
```

В стандарте _XPath_ существует ещё несколько функций, но цель статьи не дать исчерпывающую документацию по языку, а показать принципы работы тех или иных механизмов

## Отличия от CSS-селекторов

Если вы писали на JavaScript, то знаете, что можно искать элементы с помощью CSS-селекторов используя методы `querySelector()` или `querySelectorAll()`. Почему же разработчики, иногда, прибегают к помощи _XPath_ для поиска элементов внутри HTML? Всё дело в концепции поиска элементов: используя CSS возможно идти только в глубину без возможности обратиться к родительским элементам; _XPath_ позволяет в любой момент обращаться как к дочерним, так и к родительским элементам. 

---

Если вы хотите узнать, как осуществлять поиск по HTML с помощью XPath, то рекомендуем обратиться к статье [Introduction to using XPath in JavaScript](https://developer.mozilla.org/en-US/docs/Web/XPath/Introduction_to_using_XPath_in_JavaScript)

---

С помощью CSS нельзя найти все элементы `div` внутри которых есть ссылки. Мы можем найти сами ссылки, но не их родителей. XPath позволяет это сделать простым сочетанием `div[a]` . Постепенно это изменяется и в CSS появился селектор `:has()`, но его поддержка ещё не реализована всеми новыми версиями браузеров. Со временем это изменится, но, пока, реальность именно такая.

Другой пример — поиск элементов по тексту внутри них. С этой задачей CSS никогда не справится, так как такой задачи у него нет. XPath, как мы изучили, умеет это делать с помощью функции `text()`

## Кому нужен Xpath

Ответ на этот вопрос лежит на поверхности: «Всем, кто работает с XML». С одной стороны это максимальный короткий ответ, а с другой он не вызывает понимания. Вот лишь несколько примеров, кому будет полезен *_XPath_*:

**SEO-специалисты**. В своей работе специалистам по продвижению необходимо обрабатывать большие массивы данных и «вытаскивать» информацию со страниц сайта. Например, для них критичны мета-теги — дополнительная информация, в которой содержатся иконки сайтов, название страницы, описание и так далее. Используя специализированный софт они могут составлять запросы в *_XPath_* для автоматического парсинга этих данных

**Тестировщики**. При тестировании Frontend тестировщикам часто нужно проверить тот или иной вывод информации на странице. Для этого, внутри теста, выбирается элемент с нужной страницы и производится тестирование. Но как выбрать элемент на странице? На самом деле есть несколько основных способов и один из них — использование _XPath_. Так же _XPath_ можно использовать и внутри привычных всем инструментов разработчика, например DevTools который встроен в браузеры на основе движка _Chromium_ 

**Разработчики**. В разработке есть популярный класс программ, которые называются _парсеры_ — это скрипты, задача которых найти нужную информацию на страницах одного или нескольких сайтов. Например, мы хотим сравнить стоимость одного и того же товара в разных магазинах. Для такой задачи можно написать скрипт, который пройдётся по всем нужным сайтам, сравнит цены и вернёт данные. А вот найти информацию на странице можно с помощью _XPath_

Это лишь часть сценариев, где может пригодиться язык _XPath_, а реальность такова, что есть ещё десятки сценариев использования запросов с помощью этого языка

## Заключение

В этой статье мы рассмотрели где встречается XML и кому может понадобиться искать внутри по данным внутри этих документов. Научились составлять базовые запросы и изучили часто используемые конструкции XPath:

* Абсолютные и относительные пути
* Предикаты
* Поиск по атрибутам
* Операторы сравнения
* Функции

Узнали, когда поиск по HTML с помощью XPath может быть эффективнее поиска с помощью CSS-селекторов.

Язык XPath более глубокий, чем представлено в статье, но те знания, которые вы получили достаточны для того, чтобы решить большинство поставленных задач. Как и при изучении других технологий, тут важно «набивка» руки. Чем больше практики, тем более искусные запросы вы научитесь составлять
